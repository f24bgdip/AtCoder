namespace atcoder {}

#ifdef LOCAL
#define dbg(x) cerr << __LINE__ << " : " << #x << " = " << (x) << endl;
#else
#define NDEBUG
#define dbg(x) true;
#pragma GCC target("avx2")
#pragma GCC optimize("O3")
#pragma GCC optimize("unroll-loops")
#endif

#ifdef GTEST
#include <gtest/gtest.h>
#endif

#include <math.h>

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#ifdef PERF
#include <gperftools/profiler.h>
#endif

using namespace std;
using namespace atcoder;
#define fast_io                                                                \
  ios_base::sync_with_stdio(false);                                            \
  cin.tie(0);                                                                  \
  cout.tie(0);
#define ll long long int
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define reps(i, n) for (int i = 1; i <= (int)(n); i++)
#define REP(i, n) for (int i = n - 1; i >= 0; i--)
#define REPS(i, n) for (int i = n; i > 0; i--)
#define MOD (long long int)(1e9 + 7)
#define INF (int)(1e9)
#define LINF (long long int)(1e18)
#define chmax(a, b) a = (((a) < (b)) ? (b) : (a))
#define chmin(a, b) a = (((a) > (b)) ? (b) : (a))
#define all(v) v.begin(), v.end()
typedef pair<int, int> Pii;
typedef pair<ll, ll> Pll;
constexpr double PI = acos(-1);

#ifdef NDEBUG
#define CHECK(v1, op, v2)
#else
#define CHECK(v1, op, v2)                                                      \
  if (!((v1)op(v2))) {                                                         \
    cerr << "ERROR:" << (v1) << " " << (v2) << endl;                           \
    assert((v1)op(v2));                                                        \
  }
#endif

long double nCr(const int n, const int r) {
  long double ret = 1;
  rep(t, r) {
    ret *= (n - t);
    ret /= (r - t);
  }
  return ret;
}

template <typename T> string to_string(const vector<T> &vec) {
  string ret = "";
  rep(i, vec.size()) {
    ret += vec[i].to_string();
    if (i + 1 != vec.size()) {
      ret += ",";
    }
  }
  return ret;
}

template <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) {
  os << to_string(vec);
  return os;
}

uint32_t xorshift() {
  static uint32_t x = 12345789;
  static uint32_t y = 362436069;
  static uint32_t z = 521288629;
  static uint32_t w = 88675123;
  uint32_t t;
  t = x ^ (x << 11);
  x = y;
  y = z;
  z = w;
  w ^= t ^ (t >> 8) ^ (w >> 19);

  return w;
}

int rand(const uint32_t l, const uint32_t r) {
  return xorshift() % (r - l) + l;
}

uint32_t rand_other_than(const uint32_t l, const uint32_t r,
                         const uint32_t other) {
  const uint32_t num = rand(l, r - 1);
  return num + (num >= other);
}

template <typename T> const T &rand_vec(const vector<T> &vec) {
  assert(vec.size() > 0);
  return vec[rand(0, vec.size())];
}

template <typename T> void shuffle(vector<T> &vec) {
  rep(l, (int)vec.size() - 1) {
    const int idx = rand(l, vec.size());
    swap(vec[idx], vec[l]);
  }
}

class Timer {
  chrono::system_clock::time_point _start, _end;
  ll _sum = 0, _count = 0;

public:
  void start() { _start = chrono::system_clock::now(); }

  void stop() { _end = chrono::system_clock::now(); }

  void add() {
    const chrono::system_clock::time_point now = chrono::system_clock::now();
    _sum += static_cast<double>(
        chrono::duration_cast<chrono::nanoseconds>(now - _start).count());
    _count++;
  }

  ll sum() const { return _sum / 1000; }

  int count() const { return _count; }

  string average() const {
    if (_count == 0) {
      return "NaN";
    }
    return to_string(_sum / 1000 / _count);
  }

  void reset() {
    _start = chrono::system_clock::now();
    _sum = 0;
    _count = 0;
  }

  inline int ms() const {
    const chrono::system_clock::time_point now = chrono::system_clock::now();
    return static_cast<double>(
        chrono::duration_cast<chrono::microseconds>(now - _start).count() /
        1000);
  }

  inline int ns() const {
    const chrono::system_clock::time_point now = chrono::system_clock::now();
    return static_cast<double>(
        chrono::duration_cast<chrono::microseconds>(now - _start).count());
  }
};

struct Timers {
  struct Dummy {
    void start() const {}
    void add() const {}
  };
  Dummy dummy;
  const Dummy &operator[](const std::string &str) { return dummy; }
  friend ostream &operator<<(ostream &os, const Timers &timers) { return os; }
};

Timers global_timers;

/* start */

double ProbDens(const double mean, const double std, const double value) {
  const double var = std * std;
  return 1.0 / sqrt(2.0 * PI * var) *
         exp(-(value - mean) * (value - mean) / (2.0 * var));
}

// value以下となる確率
double ProbLEThan(const double mean, const double std, const double value) {
  return 0.5 * (1.0 + std::erf((value - mean) / (sqrt(2.0) * std)));
}

// value以上となる確率
double ProbGEThan(const double mean, const double std, const double value) {
  return 1.0 - ProbLEThan(mean, std, value);
}

double Lerp(const double val_0, const double val_1, const double t) {
  return val_0 + (val_1 - val_0) * t;
}

double Lerp(const double val_0, const double val_1, const double l,
            const double r, const double t) {
  if (l == r) {
    assert(val_0 == val_1);
    return val_0;
  }
  return Lerp(val_0, val_1, (t - l) / (r - l));
}

// L,N,S,CellDiff,mean log(score)
vector<tuple<int, int, int, double, double>> paramas_cell_diff = {
    {10, 60, 25, 109.0, 18.93153647664714},
    {10, 70, 25, 121.0, 18.78892452798218},
    {10, 80, 25, 121.0, 18.665496065358965},
    {10, 90, 25, 133.0, 18.54684085107763},
    {10, 100, 25, 145.0, 18.443624802452682},
    {20, 60, 25, 133.0, 18.759880549530404},
    {20, 70, 25, 145.0, 18.619360622882507},
    {20, 80, 25, 145.0, 18.4820105005146},
    {20, 90, 25, 157.0, 18.380250921582896},
    {20, 100, 25, 169.0, 18.280496714155063},
    {30, 60, 25, 157.0, 18.6315272146377},
    {30, 70, 25, 157.0, 18.475946972096466},
    {30, 80, 25, 157.0, 18.344376572943236},
    {30, 90, 25, 157.0, 18.22938914485679},
    {30, 100, 25, 217.0, 18.125004736943485},
    {40, 60, 25, 169.0, 18.483663389668003},
    {40, 70, 25, 169.0, 18.336804336796167},
    {40, 80, 25, 181.0, 18.20479610202309},
    {40, 90, 25, 217.0, 18.085672243003817},
    {40, 100, 25, 229.0, 17.98639759389953},
    {50, 60, 25, 205.0, 18.31321507902719},
    {50, 70, 25, 229.0, 18.175241661076},
    {50, 80, 25, 229.0, 18.055324524351352},
    {50, 90, 25, 253.0, 17.949013274791994},
    {50, 100, 25, 253.0, 17.852537716260272},
    {10, 60, 36, 126.0, 18.77978006838167},
    {10, 70, 36, 144.0, 18.643234447434637},
    {10, 80, 36, 162.0, 18.520541205749822},
    {10, 90, 36, 162.0, 18.415160794718425},
    {10, 100, 36, 162.0, 18.305524064545555},
    {20, 60, 36, 162.0, 18.61955565049695},
    {20, 70, 36, 180.0, 18.472342700860324},
    {20, 80, 36, 180.0, 18.350000404643474},
    {20, 90, 36, 180.0, 18.240490564162293},
    {20, 100, 36, 216.0, 18.141034466509577},
    {30, 60, 36, 162.0, 18.491566495885785},
    {30, 70, 36, 198.0, 18.327769845575958},
    {30, 80, 36, 216.0, 18.208151858846563},
    {30, 90, 36, 216.0, 18.086443273260905},
    {30, 100, 36, 234.0, 17.98852760200307},
    {40, 60, 36, 180.0, 18.35414860552018},
    {40, 70, 36, 180.0, 18.194385151114133},
    {40, 80, 36, 234.0, 18.068375292848245},
    {40, 90, 36, 234.0, 17.961528606162272},
    {40, 100, 36, 252.0, 17.85876865659691},
    {50, 60, 36, 252.0, 18.209386139290192},
    {50, 70, 36, 252.0, 18.067172600802},
    {50, 80, 36, 252.0, 17.941196880557246},
    {50, 90, 36, 252.0, 17.83042692300989},
    {50, 100, 36, 270.0, 17.731770390870068},
    {10, 60, 49, 169.0, 18.63159150651476},
    {10, 70, 49, 169.0, 18.49767028175253},
    {10, 80, 49, 193.0, 18.373879400904272},
    {10, 90, 49, 193.0, 18.262241803039753},
    {10, 100, 49, 193.0, 18.167123095091387},
    {20, 60, 49, 193.0, 18.487020803817455},
    {20, 70, 49, 193.0, 18.339925049978426},
    {20, 80, 49, 193.0, 18.2172792634417},
    {20, 90, 49, 217.0, 18.110444593598107},
    {20, 100, 49, 241.0, 18.01608516036587},
    {30, 60, 49, 217.0, 18.352072435770673},
    {30, 70, 49, 217.0, 18.205731934230148},
    {30, 80, 49, 217.0, 18.081467863698137},
    {30, 90, 49, 241.0, 17.96002408879382},
    {30, 100, 49, 265.0, 17.856366589402914},
    {40, 60, 49, 217.0, 18.22261890522824},
    {40, 70, 49, 265.0, 18.0539601731775},
    {40, 80, 49, 241.0, 17.942033747754156},
    {40, 90, 49, 265.0, 17.823943399877944},
    {40, 100, 49, 289.0, 17.725161981837893},
    {50, 60, 49, 265.0, 18.09668306077738},
    {50, 70, 49, 265.0, 17.932296807817444},
    {50, 80, 49, 289.0, 17.817884977704228},
    {50, 90, 49, 265.0, 17.699895248423363},
    {50, 100, 49, 313.0, 17.60727839733864},
    {10, 60, 64, 184.0, 18.490688422716563},
    {10, 70, 64, 184.0, 18.35417668655567},
    {10, 80, 64, 184.0, 18.237738063234534},
    {10, 90, 64, 214.0, 18.12654839994331},
    {10, 100, 64, 214.0, 18.038327100469715},
    {20, 60, 64, 214.0, 18.342075330886356},
    {20, 70, 64, 214.0, 18.206903547203037},
    {20, 80, 64, 244.0, 18.078734539862594},
    {20, 90, 64, 244.0, 17.970853616894242},
    {20, 100, 64, 274.0, 17.87122249965894},
    {30, 60, 64, 214.0, 18.234017333913233},
    {30, 70, 64, 244.0, 18.070058428351132},
    {30, 80, 64, 244.0, 17.945345039313654},
    {30, 90, 64, 304.0, 17.829178628627815},
    {30, 100, 64, 274.0, 17.727232756933933},
    {40, 60, 64, 244.0, 18.10408627491436},
    {40, 70, 64, 274.0, 17.95425864920539},
    {40, 80, 64, 274.0, 17.815728901195644},
    {40, 90, 64, 274.0, 17.712090758632087},
    {40, 100, 64, 304.0, 17.595885825711846},
    {50, 60, 64, 274.0, 17.992141006532137},
    {50, 70, 64, 274.0, 17.83397222775248},
    {50, 80, 64, 334.0, 17.697826067946316},
    {50, 90, 64, 334.0, 17.587679523306452},
    {50, 100, 64, 364.0, 17.494344708323357},
    {10, 60, 81, 201.0, 18.350914608416616},
    {10, 70, 81, 201.0, 18.21850599811954},
    {10, 80, 81, 231.0, 18.102027269830486},
    {10, 90, 81, 231.0, 17.9888215308377},
    {10, 100, 81, 231.0, 17.8855228598496},
    {20, 60, 81, 201.0, 18.221914515806844},
    {20, 70, 81, 231.0, 18.08503593184789},
    {20, 80, 81, 231.0, 17.949270072035382},
    {20, 90, 81, 291.0, 17.84694173880767},
    {20, 100, 81, 291.0, 17.748017873040983},
    {30, 60, 81, 231.0, 18.109908582989338},
    {30, 70, 81, 261.0, 17.940950963601477},
    {30, 80, 81, 261.0, 17.820175722906658},
    {30, 90, 81, 291.0, 17.719898202818275},
    {30, 100, 81, 321.0, 17.602052250134474},
    {40, 60, 81, 261.0, 18.00756557760971},
    {40, 70, 81, 261.0, 17.838518935298588},
    {40, 80, 81, 291.0, 17.709376993210803},
    {40, 90, 81, 351.0, 17.58550482747337},
    {40, 100, 81, 351.0, 17.490810218726327},
    {50, 60, 81, 291.0, 17.888000363759225},
    {50, 70, 81, 291.0, 17.72695562341106},
    {50, 80, 81, 321.0, 17.588141384744926},
    {50, 90, 81, 381.0, 17.46840176147457},
    {50, 100, 81, 381.0, 17.377774973233926},
    {10, 60, 100, 220.0, 18.222063939860938},
    {10, 70, 100, 220.0, 18.070770295195597},
    {10, 80, 100, 280.0, 17.953182703866666},
    {10, 90, 100, 250.0, 17.86358116266791},
    {10, 100, 100, 250.0, 17.766515298078648},
    {20, 60, 100, 250.0, 18.110081820112747},
    {20, 70, 100, 250.0, 17.958108951424805},
    {20, 80, 100, 280.0, 17.836291999377675},
    {20, 90, 100, 280.0, 17.71982776457147},
    {20, 100, 100, 310.0, 17.620065680002824},
    {30, 60, 100, 250.0, 17.98962641813617},
    {30, 70, 100, 280.0, 17.83585450747914},
    {30, 80, 100, 310.0, 17.716107526786267},
    {30, 90, 100, 310.0, 17.593443035501974},
    {30, 100, 100, 370.0, 17.485570407715706},
    {40, 60, 100, 280.0, 17.890460453587817},
    {40, 70, 100, 310.0, 17.731502280322044},
    {40, 80, 100, 340.0, 17.58566757162556},
    {40, 90, 100, 340.0, 17.476019066718447},
    {40, 100, 100, 400.0, 17.364044944592944},
    {50, 60, 100, 250.0, 17.77156787439668},
    {50, 70, 100, 310.0, 17.611485893403586},
    {50, 80, 100, 340.0, 17.493467795362903},
    {50, 90, 100, 370.0, 17.368071633339877},
    {50, 100, 100, 400.0, 17.264597433811183},
    {10, 60, 121, 241.0, 18.085145343703157},
    {10, 70, 121, 271.0, 17.954926380799964},
    {10, 80, 121, 271.0, 17.830233252670908},
    {10, 90, 121, 301.0, 17.725052783873124},
    {10, 100, 121, 271.0, 17.625327275960142},
    {20, 60, 121, 271.0, 17.995068240590864},
    {20, 70, 121, 301.0, 17.83832024335938},
    {20, 80, 121, 331.0, 17.708561429314056},
    {20, 90, 121, 331.0, 17.606372839290263},
    {20, 100, 121, 331.0, 17.513847730336852},
    {30, 60, 121, 301.0, 17.88876326724406},
    {30, 70, 121, 301.0, 17.723914197943557},
    {30, 80, 121, 331.0, 17.58893219393653},
    {30, 90, 121, 361.0, 17.48809605646182},
    {30, 100, 121, 361.0, 17.37363872327001},
    {40, 60, 121, 301.0, 17.785980940068967},
    {40, 70, 121, 331.0, 17.628686906922812},
    {40, 80, 121, 361.0, 17.491830659731708},
    {40, 90, 121, 391.0, 17.37740758583984},
    {40, 100, 121, 391.0, 17.271699538040362},
    {50, 60, 121, 331.0, 17.679993558675946},
    {50, 70, 121, 331.0, 17.532541802469176},
    {50, 80, 121, 361.0, 17.396759834273126},
    {50, 90, 121, 421.0, 17.274348216573518},
    {50, 100, 121, 391.0, 17.166703948268903},
    {10, 60, 144, 264.0, 17.964543605508428},
    {10, 70, 144, 264.0, 17.839216180322296},
    {10, 80, 144, 294.0, 17.712347702231558},
    {10, 90, 144, 294.0, 17.613809753596556},
    {10, 100, 144, 324.0, 17.50901661532441},
    {20, 60, 144, 294.0, 17.872277662600855},
    {20, 70, 144, 294.0, 17.730883437875338},
    {20, 80, 144, 354.0, 17.5962699350414},
    {20, 90, 144, 324.0, 17.494208935630265},
    {20, 100, 144, 384.0, 17.395123338618184},
    {30, 60, 144, 324.0, 17.7681112447284},
    {30, 70, 144, 354.0, 17.62352647033665},
    {30, 80, 144, 354.0, 17.482316871125175},
    {30, 90, 144, 384.0, 17.370989660469924},
    {30, 100, 144, 384.0, 17.27106679099436},
    {40, 60, 144, 354.0, 17.680519460704925},
    {40, 70, 144, 354.0, 17.519505152236817},
    {40, 80, 144, 354.0, 17.389182031967245},
    {40, 90, 144, 414.0, 17.26915189963446},
    {40, 100, 144, 414.0, 17.17352973860973},
    {50, 60, 144, 354.0, 17.594455079197623},
    {50, 70, 144, 384.0, 17.43740379348549},
    {50, 80, 144, 354.0, 17.2849229812636},
    {50, 90, 144, 444.0, 17.173177034396897},
    {50, 100, 144, 444.0, 17.053970874506405},
    {10, 60, 169, 289.0, 17.84986179656945},
    {10, 70, 169, 319.0, 17.7140021233003},
    {10, 80, 169, 319.0, 17.59956864304693},
    {10, 90, 169, 349.0, 17.49237396759747},
    {10, 100, 169, 349.0, 17.395770684861716},
    {20, 60, 169, 319.0, 17.75982277731436},
    {20, 70, 169, 349.0, 17.615911623626634},
    {20, 80, 169, 379.0, 17.487322957396085},
    {20, 90, 169, 379.0, 17.3731878063108},
    {20, 100, 169, 379.0, 17.277690354633368},
    {30, 60, 169, 319.0, 17.668303328223423},
    {30, 70, 169, 349.0, 17.52679404472907},
    {30, 80, 169, 379.0, 17.393287505877723},
    {30, 90, 169, 379.0, 17.27501606289026},
    {30, 100, 169, 409.0, 17.155914163673575},
    {40, 60, 169, 349.0, 17.57956646713487},
    {40, 70, 169, 409.0, 17.416931345568997},
    {40, 80, 169, 409.0, 17.289196933601744},
    {40, 90, 169, 469.0, 17.1470974966335},
    {40, 100, 169, 469.0, 17.06445456169715},
    {50, 60, 169, 379.0, 17.49034647684151},
    {50, 70, 169, 439.0, 17.32758023376481},
    {50, 80, 169, 409.0, 17.190730106687553},
    {50, 90, 169, 439.0, 17.063204773502555},
    {50, 100, 169, 529.0, 16.96022798595405},
    {10, 60, 196, 286.0, 17.734608188518052},
    {10, 70, 196, 316.0, 17.597660169848623},
    {10, 80, 196, 346.0, 17.48016652695438},
    {10, 90, 196, 346.0, 17.382424139582856},
    {10, 100, 196, 376.0, 17.279669822805253},
    {20, 60, 196, 346.0, 17.660873431361296},
    {20, 70, 196, 346.0, 17.50723834938413},
    {20, 80, 196, 406.0, 17.377242291929658},
    {20, 90, 196, 406.0, 17.268691779587567},
    {20, 100, 196, 406.0, 17.16655994155786},
    {30, 60, 196, 376.0, 17.564739153273006},
    {30, 70, 196, 346.0, 17.414855821423703},
    {30, 80, 196, 406.0, 17.280881340078423},
    {30, 90, 196, 406.0, 17.17049978528075},
    {30, 100, 196, 466.0, 17.051315258454785},
    {40, 60, 196, 376.0, 17.480336026022883},
    {40, 70, 196, 406.0, 17.32087797530837},
    {40, 80, 196, 436.0, 17.18199593369077},
    {40, 90, 196, 436.0, 17.063927171949793},
    {40, 100, 196, 526.0, 16.950951508704645},
    {50, 60, 196, 436.0, 17.389686255468174},
    {50, 70, 196, 436.0, 17.227051666634985},
    {50, 80, 196, 496.0, 17.096119402782676},
    {50, 90, 196, 496.0, 16.97669135780242},
    {50, 100, 196, 526.0, 16.867477144733087},
    {10, 60, 225, 315.0, 17.622789957137314},
    {10, 70, 225, 345.0, 17.495064571322917},
    {10, 80, 225, 345.0, 17.379210518291686},
    {10, 90, 225, 405.0, 17.26890982411041},
    {10, 100, 225, 375.0, 17.171588893352954},
    {20, 60, 225, 345.0, 17.549084042914014},
    {20, 70, 225, 375.0, 17.394720085354873},
    {20, 80, 225, 405.0, 17.267766254531796},
    {20, 90, 225, 435.0, 17.160731216693488},
    {20, 100, 225, 465.0, 17.069911635435975},
    {30, 60, 225, 375.0, 17.459504459501414},
    {30, 70, 225, 405.0, 17.303710972938074},
    {30, 80, 225, 435.0, 17.18971428706214},
    {30, 90, 225, 465.0, 17.06989813531761},
    {30, 100, 225, 525.0, 16.958626454223513},
    {40, 60, 225, 435.0, 17.379371119078225},
    {40, 70, 225, 435.0, 17.228646790661024},
    {40, 80, 225, 495.0, 17.087415423146066},
    {40, 90, 225, 465.0, 16.96552834553317},
    {40, 100, 225, 495.0, 16.86175460978977},
    {50, 60, 225, 405.0, 17.30150674484569},
    {50, 70, 225, 435.0, 17.15226414000014},
    {50, 80, 225, 525.0, 17.00379215766339},
    {50, 90, 225, 525.0, 16.865781416242726},
    {50, 100, 225, 495.0, 16.776339067849904},
    {10, 60, 256, 316.0, 17.50927479896505},
    {10, 70, 256, 376.0, 17.388800162961925},
    {10, 80, 256, 406.0, 17.26182068820191},
    {10, 90, 256, 406.0, 17.164340246673564},
    {10, 100, 256, 436.0, 17.063337857529294},
    {20, 60, 256, 406.0, 17.44026282990172},
    {20, 70, 256, 406.0, 17.30669585813984},
    {20, 80, 256, 466.0, 17.16827211958751},
    {20, 90, 256, 466.0, 17.058547880207342},
    {20, 100, 256, 466.0, 16.964001627325953},
    {30, 60, 256, 406.0, 17.362225916672365},
    {30, 70, 256, 406.0, 17.209394139224504},
    {30, 80, 256, 436.0, 17.074735834840688},
    {30, 90, 256, 466.0, 16.967118549579016},
    {30, 100, 256, 496.0, 16.85290678019276},
    {40, 60, 256, 436.0, 17.288143668329457},
    {40, 70, 256, 466.0, 17.132053533378063},
    {40, 80, 256, 526.0, 16.982056376039033},
    {40, 90, 256, 526.0, 16.863745125514647},
    {40, 100, 256, 496.0, 16.750541026244985},
    {50, 60, 256, 466.0, 17.21876630529799},
    {50, 70, 256, 466.0, 17.04927237100402},
    {50, 80, 256, 526.0, 16.900172016218722},
    {50, 90, 256, 496.0, 16.77757138684109},
    {50, 100, 256, 526.0, 16.65692354460846},
    {10, 60, 289, 349.0, 17.393852250520233},
    {10, 70, 289, 379.0, 17.280297196139493},
    {10, 80, 289, 409.0, 17.16274468432118},
    {10, 90, 289, 469.0, 17.051187221230744},
    {10, 100, 289, 439.0, 16.956824539406192},
    {20, 60, 289, 379.0, 17.338158648373334},
    {20, 70, 289, 439.0, 17.208030810106205},
    {20, 80, 289, 439.0, 17.07460448479786},
    {20, 90, 289, 469.0, 16.96832722671854},
    {20, 100, 289, 499.0, 16.86296609321333},
    {30, 60, 289, 469.0, 17.25741058152904},
    {30, 70, 289, 469.0, 17.114363228076954},
    {30, 80, 289, 499.0, 16.982881421111756},
    {30, 90, 289, 499.0, 16.863394206094902},
    {30, 100, 289, 499.0, 16.756743148679305},
    {40, 60, 289, 499.0, 17.18332240533856},
    {40, 70, 289, 499.0, 17.03201843887269},
    {40, 80, 289, 469.0, 16.890932469849396},
    {40, 90, 289, 529.0, 16.759537364389317},
    {40, 100, 289, 529.0, 16.64793050934092},
    {50, 60, 289, 469.0, 17.125288497457078},
    {50, 70, 289, 499.0, 16.966423611180844},
    {50, 80, 289, 499.0, 16.811990068163052},
    {50, 90, 289, 529.0, 16.6728224600944},
    {50, 100, 289, 499.0, 16.53714931886736},
    {10, 60, 324, 384.0, 17.307503605923145},
    {10, 70, 324, 414.0, 17.175123312832223},
    {10, 80, 324, 444.0, 17.05616721293218},
    {10, 90, 324, 474.0, 16.96462547930608},
    {10, 100, 324, 474.0, 16.866690247514693},
    {20, 60, 324, 414.0, 17.251855813228676},
    {20, 70, 324, 474.0, 17.106423728129766},
    {20, 80, 324, 474.0, 16.961439006675956},
    {20, 90, 324, 504.0, 16.86570526619219},
    {20, 100, 324, 504.0, 16.771389442503896},
    {30, 60, 324, 444.0, 17.16848405379437},
    {30, 70, 324, 504.0, 17.007994584289825},
    {30, 80, 324, 504.0, 16.88268980239334},
    {30, 90, 324, 504.0, 16.767958477745495},
    {30, 100, 324, 504.0, 16.6482353264755},
    {40, 60, 324, 504.0, 17.09442130383017},
    {40, 70, 324, 474.0, 16.93883978663853},
    {40, 80, 324, 474.0, 16.776413020802778},
    {40, 90, 324, 504.0, 16.651044832543793},
    {40, 100, 324, 504.0, 16.536144703317888},
    {50, 60, 324, 504.0, 17.029423508786923},
    {50, 70, 324, 504.0, 16.85455443802346},
    {50, 80, 324, 504.0, 16.696676624092127},
    {50, 90, 324, 504.0, 16.573123674366688},
    {50, 100, 324, 504.0, 16.436410610176726},
    {10, 60, 361, 421.0, 17.218503740000425},
    {10, 70, 361, 451.0, 17.07920646045182},
    {10, 80, 361, 451.0, 16.963762915930417},
    {10, 90, 361, 511.0, 16.86053361340272},
    {10, 100, 361, 481.0, 16.774131860533174},
    {20, 60, 361, 451.0, 17.154036960229654},
    {20, 70, 361, 481.0, 17.01674829687125},
    {20, 80, 361, 481.0, 16.882759485921046},
    {20, 90, 361, 511.0, 16.756489540092726},
    {20, 100, 361, 511.0, 16.652034581832908},
    {30, 60, 361, 511.0, 17.078376374944195},
    {30, 70, 361, 511.0, 16.927865989471506},
    {30, 80, 361, 511.0, 16.790610520489746},
    {30, 90, 361, 511.0, 16.653152484645403},
    {30, 100, 361, 511.0, 16.52173761451253},
    {40, 60, 361, 481.0, 17.003373372138537},
    {40, 70, 361, 511.0, 16.83920070921874},
    {40, 80, 361, 481.0, 16.676740275639606},
    {40, 90, 361, 511.0, 16.535328126770867},
    {40, 100, 361, 511.0, 16.39729498924309},
    {50, 60, 361, 511.0, 16.924929059058144},
    {50, 70, 361, 511.0, 16.750672684464696},
    {50, 80, 361, 511.0, 16.60079955701988},
    {50, 90, 361, 511.0, 16.460140499152235},
    {50, 100, 361, 511.0, 16.296106249534674},
    {10, 60, 400, 430.0, 17.123779629945336},
    {10, 70, 400, 460.0, 16.995669131813596},
    {10, 80, 400, 460.0, 16.867519955775595},
    {10, 90, 400, 520.0, 16.771298614215983},
    {10, 100, 400, 520.0, 16.66096192756095},
    {20, 60, 400, 490.0, 17.058328527485255},
    {20, 70, 400, 520.0, 16.9169569315589},
    {20, 80, 400, 520.0, 16.76750367957137},
    {20, 90, 400, 520.0, 16.666961987498166},
    {20, 100, 400, 520.0, 16.525556523235206},
    {30, 60, 400, 520.0, 16.985182764832548},
    {30, 70, 400, 520.0, 16.817540148280237},
    {30, 80, 400, 520.0, 16.667305064130556},
    {30, 90, 400, 520.0, 16.540227144287837},
    {30, 100, 400, 520.0, 16.408183327762302},
    {40, 60, 400, 520.0, 16.922943309184213},
    {40, 70, 400, 520.0, 16.749484648423856},
    {40, 80, 400, 520.0, 16.56023256708581},
    {40, 90, 400, 520.0, 16.41731037495513},
    {40, 100, 400, 520.0, 16.27356859501476},
    {50, 60, 400, 520.0, 16.8367517777479},
    {50, 70, 400, 490.0, 16.631202313043175},
    {50, 80, 400, 520.0, 16.48459316224576},
    {50, 90, 400, 520.0, 16.326936230907812},
    {50, 100, 400, 520.0, 16.173795940906945},
    {10, 60, 441, 441.0, 17.030048601552537},
    {10, 70, 441, 471.0, 16.895222246800483},
    {10, 80, 441, 501.0, 16.77120528860076},
    {10, 90, 441, 501.0, 16.670339408735376},
    {10, 100, 441, 501.0, 16.5574606080003},
    {20, 60, 441, 471.0, 16.97162468486907},
    {20, 70, 441, 501.0, 16.832336772553184},
    {20, 80, 441, 501.0, 16.673782294504516},
    {20, 90, 441, 501.0, 16.545479058641835},
    {20, 100, 441, 501.0, 16.406167149663602},
    {30, 60, 441, 501.0, 16.903373636272217},
    {30, 70, 441, 501.0, 16.729358334913453},
    {30, 80, 441, 501.0, 16.568924887201828},
    {30, 90, 441, 501.0, 16.423598614485414},
    {30, 100, 441, 501.0, 16.26166087615091},
    {40, 60, 441, 501.0, 16.803853983486025},
    {40, 70, 441, 501.0, 16.639682593614545},
    {40, 80, 441, 501.0, 16.439951412559623},
    {40, 90, 441, 501.0, 16.318582617661008},
    {40, 100, 441, 501.0, 16.157695430315787},
    {50, 60, 441, 501.0, 16.731002625749696},
    {50, 70, 441, 501.0, 16.52768675269255},
    {50, 80, 441, 501.0, 16.346982655755838},
    {50, 90, 441, 501.0, 16.187160202786494},
    {50, 100, 441, 501.0, 16.057987517021875},
    {-1, -1, -1, -1, -1}};

int GetCellDiff(const int l, const int n, const int s) {
  if (s > 441) {
    return 500;
  }

  const int l_0 = l / 10 * 10;
  int l_1 = l_0 + 10;
  if (l_1 > 50) {
    l_1 = 50;
  }
  const int n_0 = n / 10 * 10;
  int n_1 = n_0 + 10;
  if (n_1 > 100) {
    n_1 = 100;
  }

  // l,n
  int val_00 = -1;
  int val_01 = -1;
  int val_10 = -1;
  int val_11 = -1;

  for (int i = 0; true; i++) {
    const auto [lll, nnn, sss, cell_diff, _] = paramas_cell_diff[i];

    if (lll == -1)
      break;

    if (sss != s)
      continue;

    const int val = std::clamp((int)(cell_diff + 1e-3), 0, 500);

    if (lll == l_0) {
      if (nnn == n_0) {
        val_00 = val;
      }
      if (nnn == n_1) {
        val_01 = val;
      }
    }
    if (lll == l_1) {
      if (nnn == n_0) {
        val_10 = val;
      }
      if (nnn == n_1) {
        val_11 = val;
      }
    }
  }

  assert(val_00 != -1);
  assert(val_01 != -1);
  assert(val_10 != -1);
  assert(val_11 != -1);

  // 線形補完
  double val_0x = Lerp(val_00, val_01, n_0, n_1, n);
  double val_1x = Lerp(val_10, val_11, n_0, n_1, n);
  double val_xx = Lerp(val_0x, val_1x, l_0, l_1, l);

  return (int)std::round(val_xx);
}

// L,N,S,CellDiff,mean log(score)
vector<tuple<int, int, int, double, double>> paramas_sqrt_diff = {
    {10, 60, 1, 37.0, 19.825724099432758},
    {10, 70, 1, 37.0, 19.726897208241134},
    {10, 80, 1, 37.0, 19.63098448436122},
    {10, 90, 1, 37.0, 19.541233031199532},
    {10, 100, 1, 37.0, 19.460679093301106},
    {20, 60, 1, 37.0, 19.779470110203743},
    {20, 70, 1, 37.0, 19.66837966976002},
    {20, 80, 1, 47.0, 19.570280087227598},
    {20, 90, 1, 47.0, 19.484593303478174},
    {20, 100, 1, 47.0, 19.398088070824667},
    {30, 60, 1, 37.0, 19.75961445712786},
    {30, 70, 1, 47.0, 19.65195925865896},
    {30, 80, 1, 47.0, 19.55086184963286},
    {30, 90, 1, 47.0, 19.464803295675946},
    {30, 100, 1, 47.0, 19.382026208625106},
    {40, 60, 1, 47.0, 19.7341368207244},
    {40, 70, 1, 47.0, 19.635257731544744},
    {40, 80, 1, 47.0, 19.534717224863872},
    {40, 90, 1, 47.0, 19.448499028386316},
    {40, 100, 1, 57.0, 19.361069266646233},
    {50, 60, 1, 37.0, 19.714694634222198},
    {50, 70, 1, 47.0, 19.60865790042545},
    {50, 80, 1, 47.0, 19.509209579917286},
    {50, 90, 1, 47.0, 19.42216683878842},
    {50, 100, 1, 57.0, 19.340146785033653},
    {10, 60, 4, 68.0, 19.561724187007783},
    {10, 70, 4, 68.0, 19.451035052643984},
    {10, 80, 4, 78.0, 19.33760978186085},
    {10, 90, 4, 78.0, 19.245050286416678},
    {10, 100, 4, 88.0, 19.144644426905906},
    {20, 60, 4, 68.0, 19.493188825799596},
    {20, 70, 4, 78.0, 19.374084644463313},
    {20, 80, 4, 78.0, 19.26210073334452},
    {20, 90, 4, 78.0, 19.154624266833412},
    {20, 100, 4, 88.0, 19.069459258349102},
    {30, 60, 4, 78.0, 19.45589606098701},
    {30, 70, 4, 78.0, 19.33049274999927},
    {30, 80, 4, 78.0, 19.216984534613164},
    {30, 90, 4, 88.0, 19.122070381285727},
    {30, 100, 4, 88.0, 19.025412542490276},
    {40, 60, 4, 78.0, 19.409252488937465},
    {40, 70, 4, 78.0, 19.289374172222196},
    {40, 80, 4, 88.0, 19.18339464432854},
    {40, 90, 4, 88.0, 19.083920387635068},
    {40, 100, 4, 98.0, 18.98992460038286},
    {50, 60, 4, 78.0, 19.363145542199252},
    {50, 70, 4, 78.0, 19.243931223549946},
    {50, 80, 4, 88.0, 19.1368071006654},
    {50, 90, 4, 88.0, 19.03642187760156},
    {50, 100, 4, 98.0, 18.953701822658118},
    {10, 60, 9, 93.0, 19.2742698692318},
    {10, 70, 9, 103.0, 19.145599553578137},
    {10, 80, 9, 93.0, 19.029909852567677},
    {10, 90, 9, 103.0, 18.922291743162024},
    {10, 100, 9, 103.0, 18.816590182649776},
    {20, 60, 9, 113.0, 19.17816442964422},
    {20, 70, 9, 103.0, 19.048916581110266},
    {20, 80, 9, 113.0, 18.92546041633853},
    {20, 90, 9, 113.0, 18.823409238406388},
    {20, 100, 9, 123.0, 18.7282193818963},
    {30, 60, 9, 103.0, 19.14962041035332},
    {30, 70, 9, 113.0, 19.005541553513154},
    {30, 80, 9, 123.0, 18.883048300198435},
    {30, 90, 9, 133.0, 18.769236730567396},
    {30, 100, 9, 143.0, 18.669782244557872},
    {40, 60, 9, 103.0, 19.091404359467663},
    {40, 70, 9, 123.0, 18.953244032445674},
    {40, 80, 9, 123.0, 18.83711033141631},
    {40, 90, 9, 133.0, 18.72691986390998},
    {40, 100, 9, 133.0, 18.628265483613333},
    {50, 60, 9, 113.0, 19.02385070276609},
    {50, 70, 9, 123.0, 18.892628971352675},
    {50, 80, 9, 123.0, 18.791938669928896},
    {50, 90, 9, 123.0, 18.67300770195273},
    {50, 100, 9, 133.0, 18.585002252887122},
    {10, 60, 16, 128.0, 18.978181695560995},
    {10, 70, 16, 128.0, 18.85200121569941},
    {10, 80, 16, 144.0, 18.69644532790094},
    {10, 90, 16, 128.0, 18.607565008274864},
    {10, 100, 16, 160.0, 18.47905226895706},
    {20, 60, 16, 128.0, 18.89000218520417},
    {20, 70, 16, 128.0, 18.757082658383855},
    {20, 80, 16, 160.0, 18.622832858409843},
    {20, 90, 16, 160.0, 18.502443710513678},
    {20, 100, 16, 160.0, 18.405786442726424},
    {30, 60, 16, 144.0, 18.8256561243947},
    {30, 70, 16, 160.0, 18.69474869962983},
    {30, 80, 16, 160.0, 18.545088249816555},
    {30, 90, 16, 176.0, 18.437254985753786},
    {30, 100, 16, 176.0, 18.338115494415938},
    {40, 60, 16, 128.0, 18.77138144436214},
    {40, 70, 16, 160.0, 18.617454116674153},
    {40, 80, 16, 160.0, 18.483468582436455},
    {40, 90, 16, 176.0, 18.37212508825032},
    {40, 100, 16, 192.0, 18.26656615098023},
    {50, 60, 16, 160.0, 18.67864408105572},
    {50, 70, 16, 176.0, 18.53927073240808},
    {50, 80, 16, 160.0, 18.44910650277507},
    {50, 90, 16, 176.0, 18.32836675158075},
    {50, 100, 16, 176.0, 18.21487221547886},
    {10, 60, 25, 175.0, 18.6716454899653},
    {10, 70, 25, 175.0, 18.5496115376146},
    {10, 80, 25, 175.0, 18.411269681386965},
    {10, 90, 25, 175.0, 18.290978186366516},
    {10, 100, 25, 200.0, 18.1526277340794},
    {20, 60, 25, 175.0, 18.61554220372882},
    {20, 70, 25, 175.0, 18.478958042546992},
    {20, 80, 25, 200.0, 18.335905497524852},
    {20, 90, 25, 200.0, 18.213426972385935},
    {20, 100, 25, 200.0, 18.09787754012252},
    {30, 60, 25, 175.0, 18.540723865909335},
    {30, 70, 25, 200.0, 18.388879936804614},
    {30, 80, 25, 200.0, 18.230158331500448},
    {30, 90, 25, 200.0, 18.070791289785806},
    {30, 100, 25, 200.0, 17.91706311456833},
    {40, 60, 25, 175.0, 18.464713065168695},
    {40, 70, 25, 175.0, 18.266383113062943},
    {40, 80, 25, 200.0, 18.138361547945905},
    {40, 90, 25, 200.0, 17.98495665338013},
    {40, 100, 25, 200.0, 17.850260748980283},
    {50, 60, 25, 200.0, 18.3391752564724},
    {50, 70, 25, 200.0, 18.211105220867765},
    {50, 80, 25, 200.0, 18.087286558119796},
    {50, 90, 25, 200.0, 17.917501213342685},
    {50, 100, 25, 200.0, 17.737528612743493},
    {-1, -1, -1, -1, -1}};

int GetSQRTDiff(const int l, const int n, const int s) {
  assert(s <= 25);

  const int l_0 = l / 10 * 10;
  int l_1 = l_0 + 10;
  if (l_1 > 50) {
    l_1 = 50;
  }
  const int n_0 = n / 10 * 10;
  int n_1 = n_0 + 10;
  if (n_1 > 100) {
    n_1 = 100;
  }

  // l,n
  int val_00 = -1;
  int val_01 = -1;
  int val_10 = -1;
  int val_11 = -1;

  for (int i = 0; true; i++) {
    const auto [lll, nnn, sss, cell_diff, _] = paramas_sqrt_diff[i];
    if (lll == -1)
      break;

    if (sss != s)
      continue;

    const int val = std::clamp((int)(cell_diff + 1e-3), 0, 500);

    if (lll == l_0) {
      if (nnn == n_0) {
        val_00 = val;
      }
      if (nnn == n_1) {
        val_01 = val;
      }
    }
    if (lll == l_1) {
      if (nnn == n_0) {
        val_10 = val;
      }
      if (nnn == n_1) {
        val_11 = val;
      }
    }
  }

  assert(val_00 != -1);
  assert(val_01 != -1);
  assert(val_10 != -1);
  assert(val_11 != -1);

  // 線形補完
  double val_0x = Lerp(val_00, val_01, n_0, n_1, n);
  double val_1x = Lerp(val_10, val_11, n_0, n_1, n);
  double val_xx = Lerp(val_0x, val_1x, l_0, l_1, l);

  return (int)std::round(val_xx);
}

/* start */

vector<double> PARAMS = {2.1};

int L = 0;

enum Dir {
  // y-1, y+1, x-1, x+1
  kU,
  kD,
  kL,
  kR
};

Dir inv_dirs[4] = {kD, kU, kR, kL};

struct Pos {
  int idx_;
  Pos() {}
  explicit Pos(const int _idx) : idx_(_idx) {}
  Pos(int _x, int _y) : idx_((_y + L) % L * L + (_x + L) % L) { assert(L > 0); }
  int X() const { return pos_2_x[*this]; }
  int Y() const { return pos_2_y[*this]; }
  int Idx() const { return idx_; }
  operator int() const { return Idx(); }
  operator size_t() const { return Idx(); }
  int Manhattan(const Pos &other) const {
    return min(abs(X() - other.X()), L - abs(X() - other.X())) +
           min(abs(Y() - other.Y()), L - abs(Y() - other.Y()));
  }
  int Cost(const Pos &other) const { return (Manhattan(other) + 10) * 100; }
  void Move(const Dir dir) { *this = move_to[dir][*this]; }
  void Add(const Pos other) { *this = add[other][*this]; }
  bool operator<(const Pos &other) const { return this->Idx() < other.Idx(); }
  bool operator==(const Pos &other) const { return this->Idx() == other.Idx(); }
  bool operator!=(const Pos &other) const { return this->Idx() != other.Idx(); }
  friend ostream &operator<<(ostream &os, const Pos &pos) {
    os << pos.X() << " " << pos.Y();
    return os;
  }
  bool IsDummy() const { return this->idx_ < 0; }
  static Pos Dummy() {
    Pos p;
    p.idx_ = -1;
    return p;
  }

  static void StaticInit() {
    assert(L > 0);
    L2 = L * L;
    move_to = vector<vector<Pos>>(4, vector<Pos>(L2, Pos::Dummy()));
    add = vector<vector<Pos>>(L2, vector<Pos>(L2, Pos::Dummy()));
    pos_2_y.resize(L2);
    pos_2_x.resize(L2);

    rep(y, L) {
      rep(x, L) {
        const Pos p(x, y);
        pos_2_y[p] = y;
        pos_2_x[p] = x;
        for (int dy = -1; dy <= 1; ++dy) {
          for (int dx = -1; dx <= 1; ++dx) {
            if (abs(dy) + abs(dx) != 1)
              continue;
            const int adj_y = (y + dy + L) % L;
            const int adj_x = (x + dx + L) % L;
            if (adj_y < 0 || adj_y >= L)
              continue;
            if (adj_x < 0 || adj_x >= L)
              continue;

            Dir dir;
            if (dy == -1) {
              dir = kU;
            } else if (dy == 1) {
              dir = kD;
            } else if (dx == -1) {
              dir = kL;
            } else if (dx == 1) {
              dir = kR;
            } else {
              assert(false);
            }

            move_to[dir][p] = {adj_x, adj_y};
          }
        }

        rep(dy, L) {
          rep(dx, L) {
            Pos delta(dx, dy);
            add[delta][p] = Pos((x + dx) % L, (y + dy) % L);
          }
        }
      }
    }
  }
  static int L2;
  static vector<vector<Pos>> move_to;
  static vector<vector<Pos>> add;
  static vector<int> pos_2_x, pos_2_y;
};

vector<vector<Pos>> Pos::move_to;
vector<vector<Pos>> Pos::add;
vector<int> Pos::pos_2_x, Pos::pos_2_y;
int Pos::L2;

/* start */

int N = 0, S = 0;
int kHighCellValue = 0;
int kLowCellValue = 0;
constexpr int kHalfValue = 500;
constexpr int kMaxValue = 1000;
vector<Pos> holes;
vector<bool> exist_holes;
vector<int> hole2idxes;
using Board = vector<int>;

void Print(const Board &board, ostream &os) {
  rep(y, L) {
    rep(x, L) {
      Pos p(x, y);
      os << board[p] << " ";
    }
    os << "\n";
  }
  os.flush();
}

int Delta(int delta) { return (delta < L - delta ? delta : delta - L); }

int Execute(istream &is, ostream &os, const int i, const Pos &delta) {
  os << i << " " << Delta(delta.Y()) << " " << Delta(delta.X()) << endl;
  int ret;
  is >> ret;
  return ret;
}

struct Output {
  static void Init(istream &is) {
    if (N > 0)
      return;
    is >> L >> N >> S;
    Pos::StaticInit();
    kHighCellValue = min(1000, kHalfValue + (int)(S * PARAMS[0] + 1e-5));
    kLowCellValue = kMaxValue - kHighCellValue;
    exist_holes.assign(L * L, false);
    hole2idxes.assign(L * L, -1);
    rep(i, N) {
      int y, x;
      is >> y >> x;
      const Pos p(x, y);
      holes.push_back(p);
      exist_holes[p] = true;
      hole2idxes[p] = i;
    }
  }
  friend ostream &operator<<(ostream &os, const Output &output) { return os; }
};

namespace Colorful {

struct Pred {
  // Q[入口][出口] = 他の入口を無視したときのP(入口 == 出口)
  // Q[i]をj方向にsumを取ると1になるようにする
  vector<vector<double>> Q;
  // p / (1-p)のsum
  vector<double> Q_j_sums;
  int g = 0;
  double cost_sums = 0.0;

  Pred()
      : Q(N, vector<double>(N, 1.0 / N)),
        Q_j_sums(N, 1.0 / N / (1.0 - 1.0 / N) * N) {}

  // BS: 測定したdeltaにおける各holeの01
  void Update(const Board &board, const int i, const Pos delta,
              const int measured_value) {
    double q_i_sums = 0.0;
    rep(j, N) {
      Pos p = holes[j];
      p.Add(delta);
      Q_j_sums[j] -= Q[i][j] / (1.0 - Q[i][j] + 1e-5);
      const int mean = board[p];
      // TODO: あってる？
      if (measured_value == 0) {
        Q[i][j] *= ProbLEThan(mean, S, 0);
      } else if (measured_value == kMaxValue) {
        Q[i][j] *= ProbGEThan(mean, S, kMaxValue);
      } else {
        Q[i][j] *= ProbDens(mean, S, measured_value);
      }

      q_i_sums += Q[i][j];
    }

    rep(j, N) {
      Q[i][j] /= q_i_sums;
      chmin(Q[i][j], 1.0);
      chmax(Q[i][j], 0.0);
      Q_j_sums[j] += Q[i][j] / (1.0 - Q[i][j] + 1e-5);
    }
    ++g;
  }

  double Prob(const int i, const int j) const {
    // TODO: あってる？
    return Q[i][j] / ((1.0 - Q[i][j] + 1e-5) * Q_j_sums[j]);
  }
};

struct Colorful {
  Colorful() {}

  void Run() {
    Timer timer;
    timer.start();
    Board board(L * L);

    {
      const int kHW = L / 10;
      const int sqrt_S = (int)sqrt(S + 1e-3);
      rep(y, L) {
        rep(x, L) {
          // TODO: alignちゃんとする
          const int value =
              300 + rand(0, 20) +
              Pos(0, 0).Manhattan(Pos(x, y)) / kHW * (7 + sqrt_S * 3);
          board[Pos(x, y)] = value;
          const int y_base = y / kHW * kHW;
          const int x_base = x / kHW * kHW;

          board[Pos(x, y)] =
              board[Pos(x_base, y_base)] + y % 2 * 2 * sqrt_S + x % 2 * sqrt_S;
        }
      }
    }
    Print(board, cout);

    Pred pred;

    bitset<100> checked = 0;
    // delta_idx, 数値A * 1001 + 数値B
    vector<vector<double>> memo_prob_dens;
    rep(_t, 10000) {
      if (timer.ms() >= 3900) {
        break;
      }
      constexpr double kProbThreshold = 0.99;
      int best_i = -1;
      double min_max_prob = INF;
      rep(i, N) {
        double max_prob = 0.0;
        rep(j, N) {
          const double prob = pred.Prob(i, j);
          chmax(max_prob, prob);
        }
        if (max_prob >= kProbThreshold)
          continue;

        if (max_prob < min_max_prob) {
          min_max_prob = max_prob;
          best_i = i;
        }
      }

      if (best_i == -1)
        break;

      Pos best_delta = Pos::Dummy();
      if (checked[best_i]) {
        constexpr int kMaxManhattan = 5;
        // manhattanがkMaxManhattan以下のdeltaのうち、
        // 任意の2つのhole組の prob_A * prob_B * ProbDense() の和が小さいもの
        // TODO: より良い指標
        double min_eval = LINF;
        int delta_idx = 0;
        for (int dy = -5; dy <= 5; dy++) {
          for (int dx = -5; dx <= 5; dx++) {
            Pos delta(dx, dy);
            if (delta.Manhattan(Pos(0, 0)) > kMaxManhattan) {
              continue;
            }

            vector<Pos> poses(N);
            vector<double> probs(N);
            rep(j, N) {
              poses[j] = holes[j];
              poses[j].Add(delta);

              probs[j] = pred.Prob(best_i, j);
            }

            if (delta_idx >= (int)memo_prob_dens.size()) {
              memo_prob_dens.emplace_back();
              memo_prob_dens.back().resize(1001 * 1001);
              memo_prob_dens.back().shrink_to_fit();
              rep(j1, N) {
                Pos p1 = poses[j1];
                const int value1 = board[p1];

                rep(j2, j1) {
                  Pos p2 = poses[j2];
                  const int value2 = board[p2];

                  // TODO: 0以下や1000以上の場合など、LE,GEのほうが良いか？
                  const double prob_dens = ProbDens(value1, S, value2);
                  memo_prob_dens.back()[value1 * 1001 + value2] = prob_dens;
                }
              }
            }

            double sum_eval = 0.0;
            rep(j1, N) {
              Pos p1 = poses[j1];
              const double prob1 = probs[j1];
              const int value1 = board[p1];

              rep(j2, j1) {
                Pos p2 = poses[j2];
                const double prob2 = probs[j2];
                const int value2 = board[p2];

                const double prob_dens =
                    memo_prob_dens[delta_idx][value1 * 1001 + value2];
                const double eval = prob1 * prob2 * prob_dens;
                sum_eval += eval;
              }
            }

            if (min_eval > sum_eval) {
              min_eval = sum_eval;
              best_delta = delta;
            }

            delta_idx++;
          }
        }
      } else {
        // 未チェックだったらそのまま
        best_delta = Pos(0, 0);
      }

      checked[best_i] = true;
      const int ret = Execute(cin, cout, best_i, best_delta);
      pred.Update(board, best_i, best_delta, ret);
    }

    cout << "-1 -1 -1" << endl;
    rep(i, N) {
      int best_j = 0;
      double max_prob = 0.0;
      rep(j, N) {
        const double prob = pred.Prob(i, j);
        if (prob > max_prob) {
          best_j = j;
          max_prob = prob;
        }
      }
      cout << best_j << endl;
    }

    std::quick_exit(0);
  }
};
} // namespace Colorful

/* start */

namespace Decrypter {

struct Log {
  Pos delta;
  int value;
};

struct Pred {
  // Q[入口][出口] = 他の入口を無視したときのP(入口 == 出口)
  // Q[i]をj方向にsumを取ると1になるようにする
  vector<vector<double>> Q;
  // Q_j_sums[j] = 出口jのQのsum
  vector<double> Q_j_sums;
  int g = 0;
  double cost_sums = 0.0;

  Pred()
      : Q(N, vector<double>(N, 1.0 / N)),
        Q_j_sums(N, 1.0 / N / (1.0 - 1.0 / N) * N) {}

  void Update(const Board &board, const int i, const Log &log) {
    // Q(対応関係|結果) ~= Q(結果|対応関係) = Π Q(結果_i | 対応関係)
    double Q_i_sum = 0.0;
    rep(j, N) {
      Q_j_sums[j] -= Q[i][j] / (1.0 - Q[i][j] + 1e-5);
      Pos p = holes[j];
      p.Add(log.delta);
      const int mean = board[p];
      const int actual = log.value;
      if (actual == 0) {
        Q[i][j] *= ProbLEThan(mean, S, 0);
      } else if (actual == kMaxValue) {
        Q[i][j] *= ProbGEThan(mean, S, kMaxValue);
      } else {
        Q[i][j] *= ProbDens(mean, S, actual);
      }
      Q_i_sum += Q[i][j];
    }

    rep(j, N) {
      Q[i][j] /= Q_i_sum;
      chmin(Q[i][j], 1.0);
      chmax(Q[i][j], 0.0);
      Q_j_sums[j] += Q[i][j] / (1.0 - Q[i][j] + 1e-5);
    }
    ++g;
  }

  double Prob(const int i, const int j) const {
    // TODO: あってる？
    return Q[i][j] / ((1.0 - Q[i][j] + 1e-5) * Q_j_sums[j]);
  }
};

class Decrypter {
public:
  // 次に探索する i, deltaをgreedyに決定する
  // iは、最大確率が最も小さいワームホールとする
  // deltaは、以下2つの観点で決める
  // 1.
  // boardの値が500以上となるjの確率和と500以下となるjの確率和の差が近いほうが嬉しい
  // 2. 採掘コストが小さいほうが嬉しい <- TODO
  tuple<int, Pos> NextGreedy(const Pred &pred) {
    int best_i = 0;
    double min_max_prob = 1.0;
    rep(i, N) {
      double max_prob = 0.0;
      rep(j, N) {
        const double prob = pred.Prob(i, j);
        chmax(max_prob, prob);
      }
      if (min_max_prob > max_prob) {
        min_max_prob = max_prob;
        best_i = i;
      }
    }

    Pos best_delta = Pos::Dummy();
    double min_diff = INF;
    rep(dy, L) {
      rep(dx, L) {
        const Pos delta(dx, dy);
        //  boardの値が500以上となるjの確率 - 500以下のjの確率 の和
        double diff_sum = 0.0;
        rep(j, N) {
          Pos p = holes[j];
          p.Add(delta);
          diff_sum += (board_[p] > kHalfValue ? pred.Prob(best_i, j)
                                              : -pred.Prob(best_i, j));
        }

        const double abs_diff_sum = abs(diff_sum);
        if (abs_diff_sum < min_diff) {
          min_diff = abs_diff_sum;
          best_delta = delta;
        }
      }
    }

    assert(!best_delta.IsDummy());
    return {best_i, best_delta};
  }

  // お気持ち評価関数
  tuple<int, Pos> NextOkimochiGreedy(const Pred &pred) {
    if (delta_candidates_.size() == 0) {
      using BS = bitset<100>;
      // 各holeの有無が一致するなら、コストが小さいほうが良い
      unordered_map<BS, pair<int, Pos>> mp;
      rep(dy, L) {
        rep(dx, L) {
          const Pos delta(dx, dy);
          const int delta_cost = delta.Cost(Pos(0, 0));
          BS bs = 0;
          rep(j, N) {
            Pos p = holes[j];
            p.Add(delta);
            bs[j] = board_[p] > kHalfValue;
          }
          if (mp.count(bs) == 0) {
            mp[bs] = {delta_cost, delta};
          } else if (mp[bs].first > delta_cost) {
            mp[bs] = {delta_cost, delta};
          }
        }
      }

      for (const auto &[_, pa] : mp) {
        delta_candidates_.push_back(pa.second);
      }
    }

    int best_i = 0;
    double min_max_prob = 1.0;
    rep(i, N) {
      double max_prob = 0.0;
      rep(j, N) {
        const double prob = pred.Prob(i, j);
        chmax(max_prob, prob);
      }
      if (min_max_prob > max_prob) {
        min_max_prob = max_prob;
        best_i = i;
      }
    }

    Pos best_delta = Pos::Dummy();
    double max_eval = 0.0;
    for (const auto &delta : delta_candidates_) {
      double sum_0 = 0.0;
      double sum_1 = 0.0;
      rep(j, N) {
        Pos p = holes[j];
        p.Add(delta);
        if (board_[p] > kHalfValue) {
          sum_1 += pred.Prob(best_i, j);
        } else {
          sum_0 += pred.Prob(best_i, j);
        }
      }

      const double min_sum = min(sum_0, sum_1);
      const double delta_cost = delta.Cost(Pos(0, 0));
      const double eval = min_sum / delta_cost;
      if (max_eval < eval) {
        max_eval = eval;
        best_delta = delta;
      }
    }

    assert(!best_delta.IsDummy());
    return {best_i, best_delta};
  }

  // 2つに分割したときの小さいほうのentropyの和が最大となる用に選ぶ
  // TODO: 統計的に正しくしたい
  tuple<int, Pos> NextEntropyGreedy(const Pred &pred) {
    int best_i = 0;
    double min_max_prob = 1.0;
    rep(i, N) {
      double max_prob = 0.0;
      rep(j, N) {
        const double prob = pred.Prob(i, j);
        chmax(max_prob, prob);
      }
      if (min_max_prob > max_prob) {
        min_max_prob = max_prob;
        best_i = i;
      }
    }

    Pos best_delta = Pos::Dummy();
    double max_min_entropy = -LINF;
    rep(dy, L) {
      rep(dx, L) {
        const Pos delta(dx, dy);

        double entropy_1 = 0.0;
        double entropy_0 = 0.0;
        rep(j, N) {
          Pos p = holes[j];
          p.Add(delta);
          const auto prob = pred.Prob(best_i, j);
          const double entropy = -prob * log(prob);
          if (board_[p] > kHalfValue) {
            entropy_1 += entropy;
          } else {
            entropy_0 += entropy;
          }
        }

        const double min_entropy = min(entropy_0, entropy_1);
        if (max_min_entropy < min_entropy) {
          max_min_entropy = min_entropy;
          best_delta = delta;
        }
      }
    }

    assert(!best_delta.IsDummy());
    return {best_i, best_delta};
  }

  bool ShouldEnd(const Pred &pred) const {
    double min_max_prob = INF;
    rep(i, N) {
      double max_prob = 0.0;
      rep(j, N) {
        const double prob = pred.Prob(i, j);
        chmax(max_prob, prob);
      }
      chmin(min_max_prob, max_prob);
    }
    // cerr << min_max_prob << endl;

    return min_max_prob > 0.999;
  }

  void Run(istream &is, ostream &os, const Board &board,
           vector<vector<Log>> logs = {}) {
    board_ = board;
    // Q[入口][出口] = 他の入口を無視したときの確率(入口 == 出口)の割合
    vector<vector<double>> Q(N, vector<double>(N, 1.0));
    // logs[入口][idx] = ある入口のidx番目の結果
    if (logs.size() == 0) {
      logs.resize(N);
    }

    Pred pred;

    int log_count = 0;
    rep(i, N) {
      const auto &vec = logs[i];
      log_count += vec.size();
      for (const auto &log : vec) {
        pred.Update(board_, i, log);
      }
    }

    cerr << "LogCount: " << log_count << endl;

    rep(_, 10000 - log_count) {
      const auto [i, delta] = NextOkimochiGreedy(pred);

      os << i << " " << Delta(delta.Y()) << " " << Delta(delta.X()) << endl;
      int ret;
      is >> ret;

      Log log{delta, ret};
      logs[i].push_back(log);
      pred.Update(board_, i, log);

      const bool should_end = ShouldEnd(pred);
      if (should_end)
        break;
    }

    os << "-1 -1 -1" << endl;
    rep(i, N) {
      int max_j = 0;
      double max_prob = 0;
      os << "# ";
      rep(j, N) {
        const double prob = pred.Prob(i, j);
        os << prob << " ";
        if (prob > max_prob) {
          max_prob = prob;
          max_j = j;
        }
      }
      os << endl;
      os << "# " << max_prob << endl;
      os << max_j << endl;
    }

    std::quick_exit(0);
  }

private:
  Board board_;
  vector<Pos> delta_candidates_;
};

} // namespace Decrypter

namespace OnePoint {
using BS = bitset<100>;

struct Pred {
  // Q[入口][出口] = 他の入口を無視したときのP(入口 == 出口)
  // Q[i]をj方向にsumを取ると1になるようにする
  vector<vector<double>> Q;
  // p / (1-p)のsum
  vector<double> Q_j_sums;
  int g = 0;
  double cost_sums = 0.0;

  Pred()
      : Q(N, vector<double>(N, 1.0 / N)),
        Q_j_sums(N, 1.0 / N / (1.0 - 1.0 / N) * N) {}

  // BS: 測定したdeltaにおける各holeの01
  void Update(const Board &board, const int i, const Pos delta,
              const int measured_value) {
    double q_i_sums = 0.0;
    rep(j, N) {
      Pos p = holes[j];
      p.Add(delta);
      Q_j_sums[j] -= Q[i][j] / (1.0 - Q[i][j] + 1e-5);
      const int mean = board[p];
      // TODO: あってる？
      if (measured_value == 0) {
        Q[i][j] *= ProbLEThan(mean, S, 0);
      } else if (measured_value == kMaxValue) {
        Q[i][j] *= ProbGEThan(mean, S, kMaxValue);
      } else {
        Q[i][j] *= ProbDens(mean, S, measured_value);
      }

      q_i_sums += Q[i][j];
    }

    rep(j, N) {
      Q[i][j] /= q_i_sums;
      chmin(Q[i][j], 1.0);
      chmax(Q[i][j], 0.0);
      Q_j_sums[j] += Q[i][j] / (1.0 - Q[i][j] + 1e-5);
    }
    ++g;
  }

  double Prob(const int i, const int j) const {
    // TODO: あってる？
    return Q[i][j] / ((1.0 - Q[i][j] + 1e-5) * Q_j_sums[j]);
  }
};
struct OnePoint {
  OnePoint() {}

  Pos DecideBase() {
    Pos best_base = Pos::Dummy();
    ll min_cost = LINF;
    rep(y, L) {
      rep(x, L) {
        Pos base(x, y);
        vector<pair<Pos, ll>> hole_costs;
        rep(j, N) { hole_costs.push_back({holes[j], holes[j].Cost(base)}); }
        sort(all(hole_costs),
             [](const auto &l, const auto &r) { return l.second < r.second; });
        ll sum = 0;
        rep(idx, N) {
          ll remain_count = N - idx;
          sum += remain_count * hole_costs[idx].second;
        }
        if (min_cost > sum) {
          min_cost = sum;
          best_base = base;
        }
      }
    }

    return best_base;
  }

  Pos DecideSubBase(const Pos &main_base) {
    set<Pos> S;
    rep(y, L) {
      rep(x, L) { S.insert(Pos(x, y)); }
    }
    rep(i, N) {
      rep(j, N) {
        if (i == j)
          continue;
        // iから見たj
        const int y = holes[j].Y() - holes[i].Y();
        const int x = holes[j].X() - holes[i].X();
        const Pos p(x, y);
        S.erase(p);
      }
    }

    // 残ったもののうち最も遠いやつ
    int max_manhattan = 0;
    Pos best_delta = Pos::Dummy();
    // sub_base = main_base + best_delta;
    for (const auto &delta : S) {
      const int manhtatan = delta.Manhattan(Pos(0, 0));
      if (manhtatan > max_manhattan) {
        max_manhattan = manhtatan;
        best_delta = delta;
      }
    }

    if (best_delta.IsDummy()) {
      // subBase候補がない
      return best_delta;
    }

    Pos sub_base = main_base;
    sub_base.Add(best_delta);
    return sub_base;
  }

  void Run() {
    kHighCellValue = kHalfValue + GetCellDiff(L, N, S);
    kLowCellValue = kMaxValue - kHighCellValue;
    Board board(L * L, kLowCellValue);
    Pos base = DecideBase();
    board[base] = kHighCellValue;
    vector<bool> fixed(L * L, false);
    vector<bool> targets(L * L, false);
    {
      fixed[base] = true;
      int min_manhattan = L / 2;
      rep(y, L) {
        rep(x, L) {
          const Pos p(x, y);
          if (p.Manhattan(base) < min_manhattan) {
            targets[p] = true;
          }
        }
      }
    }
    rep(_t, 10000) {
      Board new_board = board;
      rep(y, L) {
        rep(x, L) {
          const Pos p(x, y);
          if (fixed[p] || !targets[p])
            continue;
          // そのセルと4方向の差の2乗を最小化する
          double sum = 0.0;
          for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
              if (abs(dx) + abs(dy) != 1)
                continue;
              auto adj_p = p;
              Pos delta(dx, dy);
              adj_p.Add(delta);
              sum += board[adj_p];
            }
          }
          new_board[p] = std::clamp((int)std::round(sum / 4.0), 0, kMaxValue);
        }
      }

      board = std::move(new_board);
    }
    Print(board, cout);

    Pred pred;
    vector<Pos> deltas;
    rep(i, N) {
      Pos delta = Pos(base.X() - holes[i].X(), base.Y() - holes[i].Y());
      deltas.push_back(delta);
    }

    rep(_t, 10000) {
      constexpr double kProbThreshold = 0.99;
      // 当たりを引く確率 / コスト が最も大きいもの
      // ただし閾値を超えているものは除く
      double max_eval = 0.0;
      int best_i = -1;
      int best_j = -1;
      rep(i, N) {
        bool ok = false;
        rep(j, N) {
          const double prob = pred.Prob(i, j);
          if (prob >= kProbThreshold) {
            ok = true;
            break;
          }
        }
        if (ok)
          continue;

        rep(j, N) {
          const double prob = pred.Prob(i, j);
          const double eval = prob / deltas[j].Cost(Pos(0, 0));

          if (eval > max_eval) {
            max_eval = eval;
            best_i = i;
            best_j = j;
          }
        }
      }

      if (best_i == -1)
        break;

      const int ret = Execute(cin, cout, best_i, deltas[best_j]);
      pred.Update(board, best_i, deltas[best_j], ret);
    }

    cout << "-1 -1 -1" << endl;
    rep(i, N) {
      int best_j = 0;
      double max_prob = 0.0;
      rep(j, N) {
        const double prob = pred.Prob(i, j);
        if (prob > max_prob) {
          best_j = j;
          max_prob = prob;
        }
      }
      cout << best_j << endl;
    }

    std::quick_exit(0);
  }
};
} // namespace OnePoint

struct Rectangle {
  Pos p0;
  int Y, X;
  mutable vector<Pos> holes;
  mutable bool updated = false;

  void CalcHoles() const {
    if (updated)
      return;
    updated = true;

    const int y0 = p0.Y();
    const int x0 = p0.X();

    for (int y = y0; y != (y0 + Y) % L; y = (y + 1) % L) {
      for (int x = x0; x != (x0 + X) % L; x = (x + 1) % L) {
        if (exist_holes[Pos(x, y)]) {
          holes.push_back(Pos(x, y));
        }
      }
    }
  }

  const vector<Pos> &Holes() const {
    CalcHoles();
    return holes;
  }

  vector<Pos> GeneratePoses() const {
    vector<Pos> poses;
    for (int y = p0.Y(); y != (p0.Y() + Y) % L; y = (y + 1) % L) {
      for (int x = p0.X(); x != (p0.X() + X) % L; x = (x + 1) % L) {
        poses.push_back(Pos(x, y));
      }
    }
    return poses;
  }

  double Dist(const Rectangle &other) const { return p0.Manhattan(other.p0); }

  double Cost(const Rectangle &other) const { return p0.Cost(other.p0); }

  // *this を探索するためのDelta
  // p0やholesはbase.p0から見た位置であり、
  // Deltaはp0やholesから見たbase.p0であることに注意
  Pos Delta(const Rectangle &base) const {
    const int dy = (base.p0.Y() - p0.Y() + L) % L;
    const int dx = (base.p0.X() - p0.X() + L) % L;
    return Pos(dx, dy);
  }
};

namespace Grid {
struct Plan {
  vector<Rectangle> rectangles;
  Rectangle base;

  Plan() {}

  explicit Plan(const Rectangle &_base) : base(_base) {
    // base.Y,
    // base.Xの大きさのbasetangleをbaseからY,Xの増加方向に向かって敷き詰める
    int y0_0 = base.p0.Y();
    int x0_0 = base.p0.X();

    const int y_count = (L + base.Y - 1) / base.Y;
    const int x_count = (L + base.X - 1) / base.X;
    // 0, +1, -1, +2, -2, ...
    rep(ty, y_count) {
      rep(tx, x_count) {
        int y0 = (ty + 1) / 2 * (ty % 2 == 0 ? -1 : 1) * base.Y + y0_0;
        int x0 = (tx + 1) / 2 * (tx % 2 == 0 ? -1 : 1) * base.X + x0_0;
        auto rec = Rectangle{Pos(x0, y0), base.Y, base.X};
        if (rec.Holes().size() == 0)
          continue;
        rectangles.push_back(rec);
      }
    }

    ChooseBase();
  }

  Board GenerateBoard() const {
    Board board(L * L, max(0, kLowCellValue));
    const auto poses = base.GeneratePoses();
    for (const auto p : poses) {
      board[p] = min(1000, kHighCellValue);
    }

    return board;
  }

  void Sort() {
    sort(all(rectangles), [&](const auto &l, const auto &r) {
      const auto l_eval = l.Cost(base) / (l.Holes().size() + 0.01);
      const auto r_eval = r.Cost(base) / (r.Holes().size() + 0.01);
      return l_eval < r_eval;
    });
  }

  void ChooseBase() {
    int max_count = 0;
    for (const auto &rec : rectangles) {
      if (max_count < (int)rec.Holes().size()) {
        max_count = rec.Holes().size();
        base = rec;
      }
    }

    assert(max_count > 0);
  }

  struct EstimatedCost {
    double measurement_cost;
    double placement_cost;
    int grid_turn;

    double Sum() const { return measurement_cost + placement_cost; }
  };
  EstimatedCost EstimateCost() {
    ChooseBase();
    Sort();
    set<Pos> checked;
    double measurement_cost = 0.0;
    double accumulated_cost = 0.0;
    int grid_turn = 0;
    int accumulataed_turn = 0;
    for (const auto &rec : rectangles) {
      // タイル特定
      int count_holes = rec.Holes().size();
      for (const auto p : rec.Holes()) {
        if (checked.count(p) > 0) {
          count_holes--;
        } else {
          checked.insert(p);
        }
      }
      if (count_holes == 0)
        continue;
      accumulated_cost += base.Cost(rec);
      accumulataed_turn += 1;
      measurement_cost += accumulated_cost * count_holes;
      grid_turn += accumulataed_turn * count_holes;

      // 二分探索
      measurement_cost += log2(count_holes) * count_holes * base.Cost(rec);
    }

    const int diff = min(kMaxValue, kHighCellValue - kLowCellValue);
    const double placement_cost = 2 * (base.Y + base.X) * diff * diff;

    EstimatedCost cost;
    cost.measurement_cost = measurement_cost;
    cost.placement_cost = placement_cost;
    cost.grid_turn = grid_turn;
    return cost;
  }
};

struct Planner {
  Planner(istream &_is, ostream &_os) : is(_is), os(_os) {}

  Plan Run() const {
    Plan best_plan;
    double min_cost = LINF;

    const int kMaxYX = L / 2 + 1;
    for (int YX = 1; YX <= kMaxYX; ++YX) {
      rep(y0, YX) {
        rep(x0, YX) {
          Rectangle rec{Pos(x0, y0), YX, YX};

          Plan plan(rec);

          const auto cost = plan.EstimateCost().Sum();
          if (cost < min_cost) {
            min_cost = cost;
            best_plan = plan;
          }
        }
      }
    }

    cerr << best_plan.base.p0.X() << " " << best_plan.base.X << endl;
    return best_plan;
  }

  istream &is;
  ostream &os;
};

struct Searcher {
  Searcher(istream &_is, ostream &_os) : is(_is), os(_os), logs_(N) {}
  void SearchFirst(const Plan &plan) {
    // TODO: 端をちゃんとやる

    int log_count = 0;

    // 入口候補
    // 順番に長方形を試す
    for (const auto rec : plan.rectangles) {
      int remain_count = rec.Holes().size();
      if (remain_count == 0)
        continue;
      // その長方形内の確率の合計が最も高いものを選ぶ
      // TODO: ↑高速化

      // 確率が閾値を超えたら除外
      // 規定個数に達したら次のrectangleへ。
      vector<int> candidates(N);
      std::iota(all(candidates), 0);
      while (remain_count > 0) {
        double max_prob = 0.0;
        int best_i = 0;
        for (auto itr = candidates.begin(); itr != candidates.end();) {
          const int i = *itr;
          // ある入り口が、rec内のholeのどれかに対応している確率
          double sum = 0.0;
          for (const auto p : rec.Holes()) {
            sum += pred_.Prob(i, hole2idxes[p]);
          }

          constexpr double threshold_prob = 0.95;
          if (sum > threshold_prob) {
            os << "# done! " << i << " " << sum << endl;
            remain_count--;
            itr = candidates.erase(itr);
            continue;
          }

          if (max_prob < sum) {
            max_prob = sum;
            best_i = i;
          }

          itr++;
        }

        if (remain_count <= 0)
          break;

        os << "#" << best_i << " " << max_prob << endl;

        const auto delta = rec.Delta(plan.base);
        os << best_i << " " << Delta(delta.Y()) << " " << Delta(delta.X())
           << endl;
        int ret;
        is >> ret;

        Decrypter::Log log{delta, ret};
        logs_[best_i].push_back(log);
        pred_.Update(board_, best_i, log);

        log_count++;
        if (log_count >= 10000)
          return;
      }
    }
  }
  void SearchSecond(const Plan &plan) {
    Decrypter::Decrypter decrypter;
    decrypter.Run(is, os, board_, logs_);
  }
  void Run(const Board &board, const Plan &plan) {
    board_ = board;
    SearchFirst(plan);
    SearchSecond(plan);
    std::quick_exit(0);
  }

  istream &is;
  ostream &os;
  Decrypter::Pred pred_;
  Board board_;
  vector<vector<Decrypter::Log>> logs_;
};

} // namespace Grid

/* start */

namespace Normal {
struct Rectangle {
  int y0 = 0, x0 = 0, h = 0, w = 0;

  int CountHoles() const {
    // TODO: メモ化
    int count = 0;
    for (int y = y0; y != (y0 + h) % L; y = (y + 1) % L) {
      for (int x = x0; x != (x0 + w) % L; x = (x + 1) % L) {
        count += exist_holes[Pos(x, y)];
      }
    }
    return count;
  }

  int Manhattan(const Rectangle &other) const {
    Pos p(x0, y0);
    Pos ppp(other.x0, other.y0);
    return p.Manhattan(ppp);
  }

  vector<Pos> GeneratePoses() const {
    vector<Pos> ret;
    for (int y = y0; y != (y0 + h) % L; y = (y + 1) % L) {
      for (int x = x0; x != (x0 + w) % L; x = (x + 1) % L) {
        ret.push_back(Pos(x, y));
      }
    }
    return ret;
  }
};

struct BoardParameter {
  int h, w, align_y, align_x;

  vector<Rectangle> GenerateRectangles() const {
    vector<Rectangle> ret;
    for (int dy = 0; dy < L; dy += this->h) {
      for (int dx = 0; dx < L; dx += this->w) {
        Rectangle rec;
        rec.y0 = (this->align_y + dy) % L;
        rec.x0 = (this->align_x + dx) % L;
        rec.h = dy + this->h <= L ? this->h : L % this->h;
        rec.w = dx + this->w <= L ? this->w : L % this->w;
        ret.push_back(rec);
      }
    }

    return ret;
  }
};

class Solver {
public:
  explicit Solver(istream &is) { Output::Init(is); }
  tuple<double, double, Rectangle>
  EstimateCost(const BoardParameter &params) const {
    // コスト / 総量
    vector<pair<double, Rectangle>> eval_recs;
    const auto recs = params.GenerateRectangles();
    Rectangle best_rec;
    int max_count = 0;
    for (const auto &rec : recs) {
      // TODO: どうなん？
      if (rec.h != params.h || rec.w != params.w) {
        continue;
      }
      const int count = rec.CountHoles();
      if (count > max_count) {
        max_count = count;
        best_rec = rec;
      }
    }
    if (max_count == 0) {
      return {INF, INF, {0, 0, 0, 0}};
    }

    for (const auto &rec : recs) {
      const int count = rec.CountHoles();
      if (count == 0)
        continue;
      const int manhattan = rec.Manhattan(best_rec);
      const double eval = (manhattan + 10.0) / count;
      eval_recs.push_back({eval, rec});
    }

    sort(all(eval_recs),
         [](const auto &l, const auto &r) { return l.first < r.first; });

    double measurement_cost = 0.0;
    double accumulated_cost = 0.0;
    for (const auto [eval, rec] : eval_recs) {
      // タイル特定
      const int count_holes = rec.CountHoles();
      accumulated_cost += (rec.Manhattan(best_rec) + 10) * 100;
      measurement_cost += accumulated_cost * count_holes;

      // 二分探索
      measurement_cost += log2(count_holes) * count_holes;
    }

    const int diff = min(kMaxValue, kHighCellValue - kLowCellValue);
    const double placement_cost = 2 * (params.h + params.w) * diff * diff;

    return {measurement_cost, placement_cost, best_rec};
  }
  Board Solve(const int time_limit) {
    BoardParameter best_params;
    Rectangle best_rectangle;
    double min_cost = LINF;
    const int maxHW = L / 2 + 1;
    for (int h = 1; h < maxHW; h++) {
      for (int w = 1; w < maxHW; w++) {
        rep(align_y, h) {
          rep(align_x, w) {
            BoardParameter params{h, w, align_y, align_x};
            const auto [measurement_cost, placement_cost, rectangle] =
                EstimateCost(params);
            const double cost = measurement_cost + placement_cost;
            if (min_cost > cost) {
              min_cost = cost;
              best_params = params;
              best_rectangle = rectangle;
            }
          }
        }
      }
    }

    cerr << "------------------estimated costs------------------" << endl;
    const auto [measurement_cost, placement_cost, _] =
        EstimateCost(best_params);
    cerr << best_params.h << " " << best_params.w << " " << best_params.align_y
         << " " << best_params.align_x << " " << measurement_cost << " "
         << placement_cost << "\n";
    cerr << "---------------------------------------------------" << endl;

    Board board(L * L, max(0, kLowCellValue));
    {
      const auto poses = best_rectangle.GeneratePoses();
      for (const auto p : poses) {
        board[p] = min(1000, kHighCellValue);
      }
    }
    return board;
  }

private:
};
} // namespace Normal
// #include "tensai.hpp"

namespace Barabara {
using BS = bitset<100>;

struct Pred {
  // Q[入口][出口] = 他の入口を無視したときのP(入口 == 出口)
  // Q[i]をj方向にsumを取ると1になるようにする
  vector<vector<double>> Q;
  // p / (1-p)のsum
  vector<double> Q_j_sums;
  int g = 0;
  double cost_sums = 0.0;

  Pred()
      : Q(N, vector<double>(N, 1.0 / N)),
        Q_j_sums(N, 1.0 / N / (1.0 - 1.0 / N) * N) {}

  // BS: 測定したdeltaにおける各holeの01
  void Update(const int i, const BS &bs, const int measured_value) {
    double q_i_sums = 0.0;
    rep(j, N) {
      Q_j_sums[j] -= Q[i][j] / (1.0 - Q[i][j] + 1e-5);
      const int mean = (bs[j] ? kHighCellValue : kLowCellValue);
      // TODO: あってる？
      if (measured_value == 0) {
        Q[i][j] *= ProbLEThan(mean, S, 0);
      } else if (measured_value == kMaxValue) {
        Q[i][j] *= ProbGEThan(mean, S, kMaxValue);
      } else {
        Q[i][j] *= ProbDens(mean, S, measured_value);
      }

      q_i_sums += Q[i][j];
    }

    rep(j, N) {
      Q[i][j] /= q_i_sums;
      chmin(Q[i][j], 1.0);
      chmax(Q[i][j], 0.0);
      Q_j_sums[j] += Q[i][j] / (1.0 - Q[i][j] + 1e-5);
    }
    ++g;
  }

  double Prob(const int i, const int j) const {
    // TODO: あってる？
    return Q[i][j] / ((1.0 - Q[i][j] + 1e-5) * Q_j_sums[j]);
  }
};

struct BSDelta {
  BS bs = 0;
  Pos delta;

  BSDelta() {}
  BSDelta(const Board &board, const Pos &_delta) : delta(_delta) {
    rep(j, N) {
      Pos p = holes[j];
      p.Add(delta);
      if (board[p] > kHalfValue) {
        bs[j] = true;
      }
    }
  }
};

struct Barabara {
  Barabara() {}

  Board DecideBoardBarabara() {
    Board board(L * L, kLowCellValue);
    vector<pair<int, int>> dxys{{0, 0}, {0, 1},  {1, 0},  {0, -1}, {-1, 0},
                                {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
    rep(j, N) {
      bitset<9> bs(j);
      int bs_idx = 0;
      for (auto [dx, dy] : dxys) {
        if (bs[bs_idx]) {
          Pos p(holes[j]);
          Pos delta(dx, dy);
          p.Add(delta);

          board[p] = kHighCellValue;
        }
        bs_idx++;
      }
    }

    return board;
  }

  Board DecideBoardTekito() {
    Board board(L * L, kLowCellValue);
    rep(y, L / 2 + 1) {
      rep(x, L / 2 + 1) { board[Pos(x, y)] = kHighCellValue; }
    }
    return board;
  }

  Board DecideBoardKansho() {
    Board board(L * L, kLowCellValue);
    const int max_y = L / 2 + 1;
    const int max_x = L / 2 + 1;
    rep(y, max_y + 1) {
      rep(x, max_x + 1) {
        board[Pos(x, y)] = kHighCellValue;
        if (x == 0 || y == 0 || x == max_x || y == max_y) {
          board[Pos(x, y)] =
              (kHighCellValue - kLowCellValue) * 0.25 + kLowCellValue;
        }
      }
    }

    return board;
  }

  Board DecideBoardAllSearch() {
    Board board(L * L, kLowCellValue);
    const int hw = L / 2;
    int min_diff = INF;
    Pos best_p0 = Pos::Dummy();
    rep(y0, L) {
      rep(x0, L) {
        int count = 0;
        rep(ty, hw) {
          rep(tx, hw) {
            const int y = y0 + ty;
            const int x = x0 + tx;
            Pos p(x, y);
            count += exist_holes[p];
          }
        }

        int diff = abs(count - N / 2);
        if (min_diff > diff) {
          min_diff = diff;
          best_p0 = Pos(x0, y0);
        }
      }
    }

    rep(ty, hw) {
      rep(tx, hw) {
        const int y = best_p0.Y() + ty;
        const int x = best_p0.X() + tx;
        Pos p(x, y);
        board[p] = kHighCellValue;
      }
    }
    return board;
  }

  void Run() {
    kHighCellValue = kHalfValue + std::clamp((int)(S * 1.5), 15, 500);
    kLowCellValue = kMaxValue - kHighCellValue;
    const auto board = DecideBoardAllSearch();

    Print(board, cout);

    unordered_map<BS, Pos> bs2deltas;
    rep(y, L) {
      rep(x, L) {
        const Pos delta(x, y);
        BSDelta bs_delta(board, delta);
        if (bs2deltas.count(bs_delta.bs) == 0) {
          bs2deltas[bs_delta.bs] = bs_delta.delta;
        } else if (bs2deltas[bs_delta.bs].Cost(Pos(0, 0)) >
                   bs_delta.delta.Cost(Pos(0, 0))) {
          bs2deltas[bs_delta.bs] = bs_delta.delta;
        }
      }
    }

    // TODO: 後でalign

    Pred pred;

    rep(_t, 10000) {
      constexpr double kProbThreshold = 0.99;

      // 探索対象のiを選択
      // 最大確率が最も高いもの
      // ただし、kProbThreshold以上は除く
      int best_i = -1;
      double max_max_prob = 0.0;
      rep(i, N) {
        double max_prob = 0.0;
        rep(j, N) {
          const double prob = pred.Prob(i, j);
          if (prob > max_prob) {
            max_prob = prob;
          }
        }
        if (max_prob >= kProbThreshold)
          continue;

        if (max_max_prob < max_prob) {
          max_max_prob = max_prob;
          best_i = i;
        }
      }

      if (best_i == -1)
        break;

      // 探索に使用するdeltaを選択
      // 分割したうち小さいほうの確率 / コスト
      double max_eval = 0.0;
      BS best_bs = 0;
      Pos best_delta = Pos::Dummy();
      vector<double> j2probs(N);
      rep(j, N) { j2probs[j] = pred.Prob(best_i, j); }
      for (const auto &[bs, delta] : bs2deltas) {
        double prob_0 = 0.0;
        double prob_1 = 0.0;
        rep(j, N) {
          prob_0 += j2probs[j] * !bs[j];
          prob_1 += j2probs[j] * bs[j];
        }

        const double sum = prob_0 + prob_1;
        prob_0 /= sum;
        prob_1 /= sum;
        const double eval = min(prob_0, prob_1) / delta.Cost(Pos(0, 0));

        if (eval > max_eval) {
          max_eval = eval;
          best_bs = bs;
          best_delta = delta;
        }
      }

      const auto ret = Execute(cin, cout, best_i, best_delta);
      pred.Update(best_i, best_bs, ret);
    }

    cout << "-1 -1 -1" << endl;
    rep(i, N) {
      int best_j = 0;
      double max_prob = 0.0;
      rep(j, N) {
        const double prob = pred.Prob(i, j);
        if (prob > max_prob) {
          max_prob = prob;
          best_j = j;
        }
      }

      cout << best_j << endl;
    }

    std::quick_exit(0);
  }
};
} // namespace Barabara

// NBD = neighborhood
template <class Solution, class NBDGenerator> struct SimulatedAnnealing {
public:
  SimulatedAnnealing(double end_time, double start_temp, double end_temp)
      : end_time_(end_time * 1000), // ns
        inv_time_(1.0 / end_time_), cur_time_(0.0), start_temp_(start_temp),
        end_temp_(end_temp), diff_temp_(end_temp - start_temp),
        cur_temp_(start_temp) {
    assert(start_temp >= end_temp);
    timer_.start();
  }

  Solution run(const Solution &initial_sol, NBDGenerator &nbd_generator) {
    Solution sol(initial_sol);

    int acc = 0;
    int g = 0;
    for (;; ++g) {
      if ((g & 0xf) == 0) {
#ifdef SA_MAX_G
        if (g >= SA_MAX_G) {
          break;
        }
#endif
        UpdateTime();
        UpdateTemp();
        if (cur_time_ > end_time_) {
          break;
        }
      }

      const auto nbd = nbd_generator.Generate(&sol, g);
      constexpr int mod = 1'000'000'000;
      const int r = rand(0, mod);
      if (static_cast<double>(r) / mod < exp(-nbd->Diff() / cur_temp_)) {
        acc++;
        nbd->Update(&sol);
      } else {
        nbd->Restore(&sol);
      }
    }
    cerr << "g,acc: " << g << " " << acc << endl;
    return sol;
  }

private:
  double end_time_, inv_time_, cur_time_;
  double start_temp_, end_temp_, diff_temp_, cur_temp_;
  Timer timer_;

  void UpdateTime() { cur_time_ = timer_.ns(); }
  void UpdateTemp() {
    cur_temp_ = max(0.0, start_temp_ - cur_time_ * diff_temp_ * inv_time_);
  }
};

struct Pred {
  // Q[入口][出口] = 他の入口を無視したときのP(入口 == 出口)
  // Q[i]をj方向にsumを取ると1になるようにする
  vector<vector<double>> Q;
  // p / (1-p)のsum
  vector<double> Q_j_sums;
  int g = 0;
  double cost_sums = 0.0;

  Pred()
      : Q(N, vector<double>(N, 1.0 / N)),
        Q_j_sums(N, 1.0 / N / (1.0 - 1.0 / N) * N) {}

  // BS: 測定したdeltaにおける各holeの01
  void Update(const Board &board, const int i, const Pos delta,
              const int measured_value) {
    double q_i_sums = 0.0;
    rep(j, N) {
      Pos p = holes[j];
      p.Add(delta);
      Q_j_sums[j] -= Q[i][j] / (1.0 - Q[i][j] + 1e-5);
      const int mean = board[p];
      // TODO: あってる？
      if (measured_value == 0) {
        Q[i][j] *= ProbLEThan(mean, S, 0);
      } else if (measured_value == kMaxValue) {
        Q[i][j] *= ProbGEThan(mean, S, kMaxValue);
      } else {
        Q[i][j] *= ProbDens(mean, S, measured_value);
      }

      q_i_sums += Q[i][j];
    }

    rep(j, N) {
      Q[i][j] /= q_i_sums;
      chmin(Q[i][j], 1.0);
      chmax(Q[i][j], 0.0);
      Q_j_sums[j] += Q[i][j] / (1.0 - Q[i][j] + 1e-5);
    }
    ++g;
  }

  double Prob(const int i, const int j) const {
    // TODO: あってる？
    return Q[i][j] / ((1.0 - Q[i][j] + 1e-5) * Q_j_sums[j]);
  }
};

namespace SQRT {

struct Solution {
  Board board;

  Solution(const int diff) : board(L * L, kHalfValue) {
    const int max_value = kHalfValue + diff;
    const int min_value = kHalfValue - diff;
    rep(j, N) {
      const int value =
          std::round(min_value + (double)(max_value - min_value) * j / (N - 1));
      assert(value <= kMaxValue);
      board[holes[j]] = value;
    }
  }

  void Swap(int i, int j) { swap(board[holes[i]], board[holes[j]]); }

  double Evaluate(const int i) const {
    double sum = 0.0;
    Pos p = holes[i];
    // 隣接との差分を取ろうとして3x3マス取ってるバグだけど、
    // 直すと微妙にスコアが下がるのでそのままに...
    for (int dy = -1; dy <= 1; dy++) {
      for (int dx = -1; dx <= 1; dx++) {
        Pos delta(dx, dy);
        Pos ppp = p;
        ppp.Add(delta);
        const int diff = board[p] - board[ppp];
        sum += diff * diff;
      }
    }

    return sum;
  }

  double FullEvaluate() const { return 0.0; }
};

struct NBD {
  virtual double Diff() const = 0;
  void Update(Solution *) const {}
  virtual void Restore(Solution *) const = 0;
};

struct NBDSwap : public NBD {
  NBDSwap() {}
  NBDSwap(Solution *const sol, int _i, int _j) : i(_i), j(_j) {
    diff = -(sol->Evaluate(i) + sol->Evaluate(j));
    sol->Swap(i, j);
    diff += (sol->Evaluate(i) + sol->Evaluate(j));
  }
  double Diff() const override { return diff; }
  void Restore(Solution *sol) const override { sol->Swap(i, j); }

  double diff;
  int i, j;
};

struct NBDGenerator {
  NBDGenerator() {}
  NBD *Generate(Solution *const sol, const int g) {
    if (g % 10000 == 0) {
      // 平準化
      Board new_board = sol->board;
      rep(y, L) {
        rep(x, L) {
          const Pos p(x, y);
          if (exist_holes[p])
            continue;
          // そのセルと4方向の差の2乗を最小化する
          double sum = 0.0;
          for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
              if (abs(dx) + abs(dy) != 1)
                continue;
              auto adj_p = p;
              Pos delta(dx, dy);
              adj_p.Add(delta);
              sum += sol->board[adj_p];
            }
          }
          sum += sol->board[p];
          new_board[p] = std::clamp((int)std::round(sum / 5.0), 0, kMaxValue);
        }
      }

      sol->board = std::move(new_board);
    }

    const int i = rand(0, N);
    const int j = rand_other_than(0, N, i);
    nbd_swap_ = NBDSwap(sol, i, j);
    return &nbd_swap_;
  }

private:
  NBDSwap nbd_swap_;
};

struct SQRT {
  SQRT() {}

  Board DecideHoleValues() {
    const int diff = GetSQRTDiff(L, N, S);
    Solution init_sol(diff);
    NBDGenerator gen;
    SimulatedAnnealing<Solution, NBDGenerator> SA(100, 1e1, 1e-1);
    const auto best_sol = SA.run(init_sol, gen);

    Board board = best_sol.board;
    return board;
  }

  void Run() {
    Timer timer;
    timer.start();
    Board board = DecideHoleValues();
    {
      rep(_t, 1000) {
        Board new_board = board;
        rep(y, L) {
          rep(x, L) {
            const Pos p(x, y);
            if (exist_holes[p])
              continue;
            // そのセルと4方向の差の2乗を最小化する
            double sum = 0.0;
            for (int dy = -1; dy <= 1; dy++) {
              for (int dx = -1; dx <= 1; dx++) {
                if (abs(dx) + abs(dy) != 1)
                  continue;
                auto adj_p = p;
                Pos delta(dx, dy);
                adj_p.Add(delta);
                sum += board[adj_p];
              }
            }
            new_board[p] = std::clamp((int)std::round(sum / 4.0), 0, kMaxValue);
          }
        }

        board = std::move(new_board);
      }
    }
    Print(board, cout);

    Pred pred;

    bitset<100> checked = 0;
    // 数値A * 1001 + 数値B
    vector<double> memo_prob_dens;
    {
      memo_prob_dens.resize(1001 * 1001);
      memo_prob_dens.shrink_to_fit();
      rep(value1, 1001) {
        rep(value2, 1001) {
          // TODO: 0以下や1000以上の場合など、LE,GEのほうが良いか？
          const double prob_dens = ProbDens(value1, S, value2);
          memo_prob_dens[value1 * 1001 + value2] = prob_dens;
        }
      }
    }

    rep(_t, 10000) {
      if (timer.ms() >= 3800) {
        break;
      }
      const int delta_yx = timer.ms() >= 2500 ? 2 : 1;
      constexpr double kProbThreshold = 0.99;
      int best_i = -1;
      double min_max_prob = INF;
      rep(i, N) {
        double max_prob = 0.0;
        rep(j, N) {
          const double prob = pred.Prob(i, j);
          chmax(max_prob, prob);
        }
        if (max_prob >= kProbThreshold)
          continue;

        if (max_prob < min_max_prob) {
          min_max_prob = max_prob;
          best_i = i;
        }
      }

      if (best_i == -1)
        break;

      Pos best_delta = Pos::Dummy();
      if (checked[best_i]) {
        constexpr int kMaxManhattan = 10;
        // manhattanがkMaxManhattan以下のdeltaのうち、
        // 任意の2つのhole組の prob_A * prob_B * ProbDense() の和 *
        // ManhattanCost が小さいもの
        double min_eval = LINF;

        for (int dy = -kMaxManhattan; dy <= kMaxManhattan; dy += delta_yx) {
          for (int dx = -kMaxManhattan; dx <= kMaxManhattan; dx += delta_yx) {
            Pos delta(dx, dy);
            if (delta.Manhattan(Pos(0, 0)) > kMaxManhattan) {
              continue;
            }

            vector<Pos> poses(N);
            vector<double> probs(N);
            rep(j, N) {
              poses[j] = holes[j];
              poses[j].Add(delta);

              probs[j] = pred.Prob(best_i, j);
            }

            double sum_eval = 0.0;
            const double coef = 10 + abs(dx) + abs(dy);
            rep(j1, N) {
              Pos p1 = poses[j1];
              const double prob1 = probs[j1];
              const int value1 = board[p1];

              rep(j2, j1) {
                Pos p2 = poses[j2];
                const double prob2 = probs[j2];
                const int value2 = board[p2];

                const double prob_dens = memo_prob_dens[value1 * 1001 + value2];
                const double eval = prob1 * prob2 * prob_dens;
                sum_eval += eval;
              }
              if (min_eval < sum_eval * coef) {
                sum_eval = LINF;
                break;
              }
            }

            sum_eval *= coef;

            if (min_eval > sum_eval) {
              min_eval = sum_eval;
              best_delta = delta;
            }
          }
        }

      } else {
        // 未チェックだったらそのまま
        best_delta = Pos(0, 0);
      }

      checked[best_i] = true;
      const int ret = Execute(cin, cout, best_i, best_delta);
      pred.Update(board, best_i, best_delta, ret);
    }

    cout << "-1 -1 -1" << endl;
    rep(i, N) {
      int best_j = 0;
      double max_prob = 0.0;
      rep(j, N) {
        const double prob = pred.Prob(i, j);
        if (prob > max_prob) {
          best_j = j;
          max_prob = prob;
        }
      }
      cout << best_j << endl;
    }

    std::quick_exit(0);
  }
};
} // namespace SQRT

namespace Unique {

struct Pred {
  // Q[入口][出口] = 他の入口を無視したときのP(入口 == 出口)
  // Q[i]をj方向にsumを取ると1になるようにする
  vector<vector<double>> Q;
  // p / (1-p)のsum
  vector<double> Q_j_sums;
  int g = 0;
  double cost_sums = 0.0;

  Pred()
      : Q(N, vector<double>(N, 1.0 / N)),
        Q_j_sums(N, 1.0 / N / (1.0 - 1.0 / N) * N) {}

  // BS: 測定したdeltaにおける各holeの01
  void Update(const Board &board, const int i, const Pos delta,
              const int measured_value) {
    double q_i_sums = 0.0;
    rep(j, N) {
      Pos p = holes[j];
      p.Add(delta);
      Q_j_sums[j] -= Q[i][j] / (1.0 - Q[i][j] + 1e-5);
      const int mean = board[p];
      // TODO: あってる？
      if (measured_value == 0) {
        Q[i][j] *= ProbLEThan(mean, S, 0);
      } else if (measured_value == kMaxValue) {
        Q[i][j] *= ProbGEThan(mean, S, kMaxValue);
      } else {
        Q[i][j] *= ProbDens(mean, S, measured_value);
      }

      q_i_sums += Q[i][j];
    }

    rep(j, N) {
      Q[i][j] /= q_i_sums;
      chmin(Q[i][j], 1.0);
      chmax(Q[i][j], 0.0);
      Q_j_sums[j] += Q[i][j] / (1.0 - Q[i][j] + 1e-5);
    }
    ++g;
  }

  double Prob(const int i, const int j) const {
    // TODO: あってる？
    return Q[i][j] / ((1.0 - Q[i][j] + 1e-5) * Q_j_sums[j]);
  }
};

struct Solution {
  // 各holeに割り振るvalue
  vector<int> j2values;

  Solution(const int interval) : j2values(N) {
    int value = kHalfValue - N / 2 * interval;
    assert(value >= 0);
    rep(j, N) {
      assert(value <= kMaxValue);
      j2values[j] = value;
      value += interval;
    }
  }

  void Swap(int i, int j) { swap(j2values[i], j2values[j]); }

  double FullEvaluate() const {
    // (値の差)^2 / (マンハッタン距離)^2 の和
    // 小さいほうが嬉しい
    // TODO: 改善
    double sum = 0.0;
    rep(i, N) {
      const Pos &pi = holes[i];
      rep(j, i) {
        const Pos &pj = holes[j];
        const int manhattan = pi.Manhattan(pj);
        const int value_diff = j2values[i] - j2values[j];
        sum += (double)value_diff * value_diff / (manhattan * manhattan);
      }
    }

    return sum;
  }
};

struct NBD {
  virtual double Diff() const = 0;
  void Update(Solution *) const {}
  virtual void Restore(Solution *) const = 0;
};

struct NBDSwap : public NBD {
  NBDSwap() {}
  NBDSwap(Solution *const sol, int _i, int _j) : i(_i), j(_j) {
    diff = -sol->FullEvaluate();
    sol->Swap(i, j);
    diff += sol->FullEvaluate();
  }
  double Diff() const override { return diff; }
  void Restore(Solution *sol) const override { sol->Swap(i, j); }

  double diff;
  int i, j;
};

struct NBDGenerator {
  NBDGenerator() {}
  NBD *Generate(Solution *const sol, const int g) {
    const int i = rand(0, N);
    const int j = rand_other_than(0, N, i);
    nbd_swap_ = NBDSwap(sol, i, j);
    return &nbd_swap_;
  }

private:
  NBDSwap nbd_swap_;
};

struct Unique {
  Unique() {}

  Board DecideHoleValues() {
    Solution init_sol(3);
    NBDGenerator gen;
    SimulatedAnnealing<Solution, NBDGenerator> SA(20000, 1e-3, 1e-3);
    const auto best_sol = SA.run(init_sol, gen);

    Board board(L * L, kHalfValue);
    rep(j, N) {
      const auto p = holes[j];
      board[p] = best_sol.j2values[j];
    }
    return board;
  }

  void Run() {
    Board board = DecideHoleValues();
    {
      rep(_t, 1000) {
        Board new_board = board;
        rep(y, L) {
          rep(x, L) {
            const Pos p(x, y);
            if (exist_holes[p])
              continue;
            // そのセルと4方向の差の2乗を最小化する
            double sum = 0.0;
            for (int dy = -1; dy <= 1; dy++) {
              for (int dx = -1; dx <= 1; dx++) {
                if (abs(dx) + abs(dy) != 1)
                  continue;
                auto adj_p = p;
                Pos delta(dx, dy);
                adj_p.Add(delta);
                sum += board[adj_p];
              }
            }
            new_board[p] = std::clamp((int)std::round(sum / 4.0), 0, kMaxValue);
          }
        }

        board = std::move(new_board);
      }
    }
    Print(board, cout);

    Pred pred;

    bitset<100> checked = 0;
    rep(_t, 10000) {
      constexpr double kProbThreshold = 0.99;
      int best_i = -1;
      double min_max_prob = INF;
      rep(i, N) {
        double max_prob = 0.0;
        rep(j, N) {
          const double prob = pred.Prob(i, j);
          chmax(max_prob, prob);
        }
        if (max_prob >= kProbThreshold)
          continue;

        if (max_prob < min_max_prob) {
          min_max_prob = max_prob;
          best_i = i;
        }
      }

      if (best_i == -1)
        break;

      Pos best_delta = Pos::Dummy();
      if (checked[best_i]) {
        constexpr int kMaxManhattan = 5;
        // manhattanがkMaxManhattan以下のdeltaのうち、
        // 任意の2つのhole組の prob_A * prob_B * ProbDense() の和が小さいもの
        // TODO: より良い指標
        double min_eval = LINF;
        for (int dy = -5; dy <= 5; dy++) {
          for (int dx = -5; dx <= 5; dx++) {
            Pos delta(dx, dy);
            if (delta.Manhattan(Pos(0, 0)) > kMaxManhattan) {
              continue;
            }

            vector<Pos> poses(N);
            vector<double> probs(N);
            rep(j, N) {
              poses[j] = holes[j];
              poses[j].Add(delta);

              probs[j] = pred.Prob(best_i, j);
            }

            double sum_eval = 0.0;
            rep(j1, N) {
              Pos p1 = poses[j1];
              const double prob1 = probs[j1];
              const int value1 = board[p1];

              rep(j2, j1) {
                Pos p2 = poses[j2];
                const double prob2 = probs[j2];
                const int value2 = board[p2];

                const double prob_dens = ProbDens(value1, S, value2);
                const double eval = prob1 * prob2 * prob_dens;
                sum_eval += eval;
              }
            }

            if (min_eval > sum_eval) {
              min_eval = sum_eval;
              best_delta = delta;
            }
          }
        }

      } else {
        // 未チェックだったらそのまま
        best_delta = Pos(0, 0);
      }

      checked[best_i] = true;
      const int ret = Execute(cin, cout, best_i, best_delta);
      pred.Update(board, best_i, best_delta, ret);
    }

    cout << "-1 -1 -1" << endl;
    rep(i, N) {
      int best_j = 0;
      double max_prob = 0.0;
      rep(j, N) {
        const double prob = pred.Prob(i, j);
        if (prob > max_prob) {
          best_j = j;
          max_prob = prob;
        }
      }
      cout << best_j << endl;
    }

    std::quick_exit(0);
  }
};
} // namespace Unique

int main(int argc, char *argv[]) {
  fast_io;

  if (argc >= 2) {
    int idx = 0;
    for (int i = 1; i < argc; ++i) {
      PARAMS[idx++] = std::stod(argv[i]);
    }
  }

  Output::Init(cin);

  if (S <= 16) {
    SQRT::SQRT solver;
    solver.Run();
  } else if (S <= 0) {
    Unique::Unique solver;
    solver.Run();
  } else if (S <= 16) {
    Colorful::Colorful solver;
    solver.Run();
  } else if (S <= 16) {
    // Tensai::Tensai solver;
    Barabara::Barabara solver;
    solver.Run();
  } else {
    OnePoint::OnePoint solver;
    solver.Run();
  }
  return 0;
}