A - Please Sign / 
実行時間制限: 2 sec / メモリ制限: 1024 MB

配点 : 
400 点

問題文
長さ N の整数列 A=(A(1)​ ,A(2)​ ,⋯,A(N)​ )，および長さ N−1 の整数列 P=(P(2)​ ,⋯,P(N)​ ) が与えられます． P の添字が 2 から始まることに注意してください． また，1≤P(i)​ <i が保証されます．

あなたは今から以下の操作を 10^100  回繰り返します．
各 i=2,⋯,N について，この順に，A(P(i))​ ​  の値を A(P(i))​ ​ +A(i)​  で置き換える．
すべての操作が終了したときの A(1)​  が 正, 負, 0 のいずれになるかを求めてください．

制約
2≤N≤250000
−10^9 ≤A(i)​ ≤10^9
1≤P(i)​ <i
入力される値はすべて整数．

入力
入力は以下の形式で標準入力から与えられる．
N
A(1)​  A(2)​  ⋯ A(N)​
P(2)​  ⋯ P(N)​

出力
すべての操作が終了したときの A(1)​  が正である場合 + を出力せよ． 負である場合 - を出力せよ． 0 である場合 0 を出力せよ．

入力例 1
4
1 -2 3 -4
1 2 3

出力例 1
-

解説
最初の数回の操作の結果を以下に示します．
1 回目の操作
操作前: A=(1,−2,3,−4)
i=2 について処理: A(1)​  の値を A(1)​ +A(2)​ =1+(−2)=−1 で置き換える．
i=3 について処理: A(2)​  の値を A(2)​ +A(3)​ =−2+3=1 で置き換える．
i=4 について処理: A(3)​  の値を A(3)​ +A(4)​ =3+(−4)=−1 で置き換える．
操作後: A=(−1,1,−1,−4)
2 回目の操作後，A=(0,0,−5,−4) となる．
3 回目の操作後，A=(0,−5,−9,−4) となる．
4 回目の操作後，A=(−5,−14,−13,−4) となる．
⋮
操作を 10^100  回行うと，A(1)​  は負になります． よって - を出力すべきです．


B - Subsegments with Small Sums / 
実行時間制限: 2 sec / メモリ制限: 1024 MB

配点 : 
500 点

問題文
正整数 S が与えられます． 
正整数列 x に対し，f(x) を以下のように定めます．
x をいくつかの連続部分列に分解することを考える． このとき，どの連続部分列についても要素の総和が S 以下でなくてはならない． このような分解における連続部分列の個数の最小値を f(x) の値とする．
なお，この問題の制約下では f の値が必ず定義できることが証明できます．
正整数列 A=(A(1)​ ,A(2)​ ,⋯,A(N)​ ) が与えられます． 
∑1≤l≤r≤N(f(A(l)​ ,A(l)+1​ ,⋯,A(r)​)) の値を求めてください．

制約
1≤N≤250000
1≤S≤10^15
1≤A(i)​ ≤min(S,10^9) 
入力される値はすべて整数．

入力
入力は以下の形式で標準入力から与えられる．
N S
A(1)​  A(2)​  ⋯ A(N)​
 
出力
答えを出力せよ．

入力例 1
3 3
1 2 3

出力例 1
8

例えば x=(1,2,3) を考えると，(1,2),(3) という分解が条件を満たし， かつ 2 個未満の連続部分列に分解した場合は条件を満たさないため，f((1,2,3))=2 です．
ありうる l,r とそれに対応する f の値は以下の通りです．
(l,r)=(1,1): f((1))=1
(l,r)=(1,2): f((1,2))=1
(l,r)=(1,3): f((1,2,3))=2
(l,r)=(2,2): f((2))=1
(l,r)=(2,3): f((2,3))=2
(l,r)=(3,3): f((3))=1
よって答えは 1+1+2+1+2+1=8 になります．


C - Not So Consecutive / 
実行時間制限: 2 sec / メモリ制限: 1024 MB

配点 : 
600 点

問題文
整数 N が与えられます． 長さ N の整数列 x=(x(1)​ ,x(2)​ ,⋯,x(N)​ ) は，以下の条件を満たすとき（そしてそのときのみ）よい数列と呼ばれます．
x の各要素は 1 以上 N 以下の整数である．各整数 i (1≤i≤N) に対し，i が i+1 個以上連続して並ぶような場所が x 内に存在しない．長さ N の整数列 A=(A(1)​ ,A(2)​ ,⋯,A(N)​ ) が与えられます． A の各要素は 1 以上 N 以下の整数もしくは −1 です． それぞれの −1 を 1 以上 N 以下の整数に置き換えることで得られるよい数列の個数を 998244353 で割ったあまりを求めてください．

制約
1≤N≤5000
A(i)​ =−1 もしくは 1≤A(i)​ ≤N
入力される値はすべて整数．

入力
入力は以下の形式で標準入力から与えられる．
N
A(1)​  A(2)​  ⋯ A(N)​

出力
答えを出力せよ．

入力例 1
2
-1 -1

出力例 1
3

解説
それぞれの −1 を 1 以上 2 以下の整数で置き換えて得られる数列は 4 通りあります．
ここで A=(1,1) について考えると，1 が 2 個連続してしまうためよい数列ではありません．
それ以外の A=(1,2),(2,1),(2,2) について考えると，これらはすべてよい数列です．
よって答えは 3 です


D - Add to Make a Permutation / 
実行時間制限: 2 sec / メモリ制限: 1024 MB

配点 : 
700 点

問題文
長さ N の整数列 A=(A(1)​ ,A(2)​ ,⋯,A(N)​ ) が与えられます． A の各要素は 0 以上 N−1 以下の整数です．
あなたは以下の操作を 0 回以上行うことができます．
A の中からちょうど M 個の要素を選ぶ． そして，選んだ要素の値をそれぞれ 1 増加させる． 増加させたあとに値が N になっている要素があれば，その値を 0 に変更する．
あなたの目標は A を (0,1,⋯,N−1) の順列にすることです． 目標が達成可能か判定し，可能ならば必要な最小の操作回数を求めてください．

制約
2≤N≤250000
1≤M≤N−1
0≤A(i)​ ≤N−1
入力される値はすべて整数．

入力
入力は以下の形式で標準入力から与えられる．
N M
A(1)​  A(2)​  ⋯ A(N)​

出力
目標が達成不可能な場合，−1 を出力せよ． 可能な場合，必要な最小の操作回数を出力せよ．

入力例 1
3 2
0 1 1

出力例 1
2

以下のように操作すると 2 回の操作で目標を達成できます．

初期状態: A=(0,1,1)
1 回目の操作: A(1)​ ,A(2)​  を選んで操作を行い，A=(1,2,1) になる．
2 回目の操作: A(2)​ ,A(3)​  を選んで操作を行い，A=(1,0,2) になる．
2 回未満の操作で目標を達成することはできないため，答えは 2 になります．